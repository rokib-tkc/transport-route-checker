<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Transport Route Checker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; font-family: Arial, sans-serif; }

    body { margin: 0; padding: 20px; background: #f5f5f5; color: #222; }

    h1 { margin-top: 0; font-size: 24px; text-align: center; }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: #ffffff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    .search-section {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .search-section label { font-weight: bold; }

    .search-input-wrapper {
      flex: 1 1 200px;
      display: flex;
      gap: 8px;
    }

    input[type="text"] {
      flex: 1;
      padding: 8px 10px;
      font-size: 14px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      background: #0078d4;
      color: #fff;
    }
    button:hover { background: #005ea3; }

    .results-header { margin-top: 10px; font-size: 14px; font-weight: bold; }

    .no-results {
      margin-top: 10px;
      padding: 10px;
      border-radius: 5px;
      font-size: 13px;
      background: #ffe5e5;
      color: #a00;
    }

    .channel-block {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      background: #fafafa;
      border: 1px solid #e0e0e0;
    }

    .channel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .channel-title { font-size: 16px; font-weight: bold; }

    .channel-rules-trigger {
      font-size: 12px;
      color: #0078d4;
      text-decoration: underline;
      cursor: help;
      white-space: nowrap;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 5px;
      font-size: 13px;
      table-layout: fixed;
    }

    th, td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      text-align: left;
      overflow-wrap: break-word;
    }

    th { background: #f0f0f0; font-weight: bold; }

    .lead-time { white-space: nowrap; }

    #channelTooltip {
      position: fixed;
      z-index: 9999;
      max-width: 320px;
      padding: 10px;
      background: #ffffff;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      font-size: 12px;
      line-height: 1.4;
      display: none;
    }

    @media (max-width: 600px) {
      .search-section { flex-direction: column; align-items: flex-start; }
      .search-input-wrapper { width: 100%; }
      button { width: 100%; }
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Transport Route Checker</h1>

    <div style="text-align:center; margin-top:6px; margin-bottom:25px;">
      <a href="https://tkcomponents-my.sharepoint.com/:x:/g/personal/russell_threlfall_tkc_co_uk/EWPM8aDcNv1Ot6_xsKSVVjMBJUvW04URqVDeewAD99EOhA?e=ufnQPC"
         target="_blank"
         style="font-size:13px; color:#0078d4; text-decoration:underline;">
        Click here for live Route Status updates
      </a>
    </div>

    <div class="search-section">
      <label for="postcodeInput">Postcode prefix:</label>
      <div class="search-input-wrapper">
        <input id="postcodeInput" type="text" placeholder="e.g. M34" autocomplete="off">
        <button id="searchButton">Search</button>
      </div>
    </div>

    <div id="resultsMeta" class="results-header" style="display:none;"></div>
    <div id="resultsContainer"></div>

    <div id="noResults" class="no-results" style="display:none;">
      No routing information found for that postcode prefix.
    </div>
  </div>

  <div id="channelTooltip"></div>

  <script>
    // ============================================================
    // DELIMITER-DETECTING PARSER (comma CSV or tab TSV)
    // ============================================================

    function stripBom(s) {
      return s && s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;
    }

    function detectDelimiter(headerLine) {
      // prefer tab if present (your screenshot showed tabs)
      if (headerLine.includes("\t")) return "\t";
      return ",";
    }

    function splitLine(line, delim) {
      // Simple split for your files (no embedded commas/tabs expected).
      // If you ever need quoted CSV support, tell me and Iâ€™ll upgrade this.
      return line.split(delim).map(x => x.trim());
    }

    function parseDelimited(text) {
      const cleanedText = stripBom(String(text || ""));
      const lines = cleanedText.split(/\r?\n/).filter(l => l.trim() !== "");
      if (!lines.length) return { headers: [], rows: [] };

      const delim = detectDelimiter(lines[0]);
      const headers = splitLine(lines[0], delim);

      const rows = [];
      for (const line of lines.slice(1)) {
        const cols = splitLine(line, delim);
        const obj = {};
        headers.forEach((h, i) => obj[h] = (cols[i] || ""));
        rows.push(obj);
      }
      return { headers, rows };
    }

    // ============================================================
    // CHANNEL RULES (LOADED FROM channel_rules.csv)
    // ============================================================

    let channelRules = {};

    function loadChannelRules() {
      fetch("channel_rules.csv?cb=" + Date.now())
        .then(r => {
          if (!r.ok) throw new Error("Failed to load channel_rules.csv");
          return r.text();
        })
        .then(text => {
          const parsed = parseDelimited(text);
          const rows = parsed.rows;

          const out = {};
          rows.forEach(row => {
            const channel = (row.channel || "").trim();
            const rulesCell = (row.rules || "").trim();
            if (!channel) return;

            const parts = rulesCell.split("|").map(p => p.trim()).filter(Boolean);
            let html = `<strong>${channel} rules</strong>`;
            if (parts.length) html += "<br>" + parts.map(p => "- " + p).join("<br>");
            out[channel] = html;
          });

          channelRules = out;
        })
        .catch(err => {
          console.error("Error loading channel_rules.csv:", err);
          channelRules = {};
        });
    }

    // ============================================================
    // BANK HOLIDAYS (LOADED FROM bank_holidays.csv)
    // ============================================================

    let bankHolidaySet = new Set(); // ISO YYYY-MM-DD

    function toISODateKey(dateObj) {
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2, "0");
      const d = String(dateObj.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    function loadBankHolidays() {
      return fetch("bank_holidays.csv?cb=" + Date.now())
        .then(r => {
          if (!r.ok) throw new Error("Failed to load bank_holidays.csv");
          return r.text();
        })
        .then(text => {
          const parsed = parseDelimited(text);
          const rows = parsed.rows;

          const set = new Set();
          rows.forEach(row => {
            const d = (row.date || "").trim();           // YYYY-MM-DD
            const div = (row.division || "").trim();     // england-and-wales
            if (!d) return;
            if (!div || div === "england-and-wales") set.add(d);
          });

          bankHolidaySet = set;
        })
        .catch(err => {
          console.warn("Bank holidays not loaded (continuing without them):", err);
          bankHolidaySet = new Set();
        });
    }

    // ============================================================
    // ROUTES PARSING (routes.csv can be comma or tab separated)
    // ============================================================

    function normalisePrefix(v) {
      return String(v || "").toUpperCase().replace(/\s+/g, "").trim();
    }

    function parseRoutes(text) {
      const parsed = parseDelimited(text);
      const rows = parsed.rows;

      return rows.map(row => {
        const daysArray = String(row.days || "")
          .split("|")
          .map(d => d.trim())
          .filter(Boolean);

        return {
          prefix: normalisePrefix(row.prefix),
          route: String(row.route || "").trim(),
          channel: String(row.channel || "").trim(),
          serviceType: String(row.serviceType || "").trim(),
          leadTime: String(row.leadTime || "").trim(),
          days: daysArray
        };
      }).filter(r => r.prefix && r.channel); // drop junk rows
    }

    // ============================================================
    // NEXT DELIVERY CALCULATION (2pm cutoff + working days + bank holidays)
    // ============================================================

    function parseLeadTimeWorkingDays(leadTimeText) {
      const t = String(leadTimeText || "").toLowerCase();
      const m = t.match(/(\d+)/);
      if (m) return parseInt(m[1], 10);
      if (t.includes("next day")) return 1;
      if (t.includes("same day")) return 0;
      return 0;
    }

    function isWorkingDay(dateObj) {
      const day = dateObj.getDay(); // 0 Sun ... 6 Sat
      if (day === 0 || day === 6) return false;
      const iso = toISODateKey(dateObj);
      if (bankHolidaySet.has(iso)) return false;
      return true;
    }

    function startOfDay(dateObj) {
      return new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate());
    }

    function nextWorkingDay(dateObj) {
      let d = startOfDay(dateObj);
      do { d.setDate(d.getDate() + 1); } while (!isWorkingDay(d));
      return d;
    }

    function addWorkingDays(dateObj, n) {
      let d = startOfDay(dateObj);
      let remaining = n;
      while (remaining > 0) {
        d.setDate(d.getDate() + 1);
        if (isWorkingDay(d)) remaining--;
      }
      return d;
    }

    function weekdayName(dateObj) {
      return dateObj.toLocaleDateString("en-GB", { weekday: "long" });
    }

    function formatDayDate(dateObj) {
      const day = weekdayName(dateObj);
      const dateStr = dateObj.toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit", year: "2-digit" });
      return `${day} ${dateStr}`;
    }

    function findNextDeliveryDate(allowedDays, leadTimeText) {
      if (!Array.isArray(allowedDays) || allowedDays.length === 0) return null;

      const allowed = new Set(allowedDays.map(d => String(d).trim().toLowerCase()));

      const now = new Date();
      const cutoffHour = 14; // 2pm
      const afterCutoff = (now.getHours() > cutoffHour) || (now.getHours() === cutoffHour && now.getMinutes() > 0);

      let start = startOfDay(now);
      if (!isWorkingDay(start)) start = nextWorkingDay(start);
      if (afterCutoff) start = nextWorkingDay(start);

      const leadDays = parseLeadTimeWorkingDays(leadTimeText);
      const earliest = (leadDays > 0) ? addWorkingDays(start, leadDays) : start;

      let d = startOfDay(earliest);
      for (let i = 0; i < 90; i++) {
        const dayLower = weekdayName(d).toLowerCase();
        if (allowed.has(dayLower) && d >= earliest) return d;
        d.setDate(d.getDate() + 1);
      }
      return null;
    }

    // ============================================================
    // CORE HELPERS
    // ============================================================

    function normaliseInputPostcode(raw) {
      return raw ? raw.toUpperCase().replace(/\s+/g, "") : "";
    }

    function findBestMatchingPrefix(routingData, cleaned) {
      const prefixes = [...new Set(routingData.map(r => r.prefix))];
      const matches = prefixes.filter(p => cleaned.startsWith(p));
      return matches.sort((a, b) => b.length - a.length)[0] || null;
    }

    function groupByChannel(rows) {
      return rows.reduce((acc, r) => {
        acc[r.channel] = acc[r.channel] || [];
        acc[r.channel].push(r);
        return acc;
      }, {});
    }

    function sortDays(days) {
      const order = ["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"];
      return days.slice().sort((a, b) => {
        const aIndex = order.indexOf(String(a).toUpperCase());
        const bIndex = order.indexOf(String(b).toUpperCase());
        return aIndex - bIndex;
      });
    }

    function buildResultsHTML(rows, usedPrefix, originalInput) {
      const grouped = groupByChannel(rows);
      const channels = Object.keys(grouped).sort();
      const resultsContainer = document.getElementById("resultsContainer");
      const resultsMeta = document.getElementById("resultsMeta");
      const noResults = document.getElementById("noResults");

      if (!channels.length) {
        resultsMeta.style.display = "none";
        resultsContainer.innerHTML = "";
        noResults.style.display = "block";
        return;
      }

      noResults.style.display = "none";
      resultsMeta.style.display = "block";
      resultsMeta.textContent =
        `Results for postcode: ${originalInput || usedPrefix} (matched prefix: ${usedPrefix})`;

      let html = "";

      channels.forEach(channel => {
        const rowsForChannel = grouped[channel];

        const route = rowsForChannel[0].route;
        const serviceType = rowsForChannel[0].serviceType;
        const leadTime = rowsForChannel[0].leadTime;

        const allDays = sortDays([...new Set(rowsForChannel.flatMap(r => r.days))]);

        const nextDate = findNextDeliveryDate(allDays, leadTime);
        const nextDeliveryText = nextDate ? formatDayDate(nextDate) : "";

        html += `
          <div class="channel-block">
            <div class="channel-header">
              <div class="channel-title">${channel}</div>
              <div class="channel-rules-trigger" data-channel="${channel}">
                Hover here for channel rules
              </div>
            </div>
            <table>
              <colgroup>
                <col style="width: 22%">
                <col style="width: 35%">
                <col style="width: 12%">
                <col style="width: 12%">
                <col style="width: 19%">
              </colgroup>
              <thead>
                <tr>
                  <th>Route</th>
                  <th>Delivery Days</th>
                  <th>Delivery Type</th>
                  <th>Lead Time</th>
                  <th>Next Delivery</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>${route}</td>
                  <td>${allDays.join(", ")}</td>
                  <td>${serviceType}</td>
                  <td class="lead-time">${leadTime}</td>
                  <td class="lead-time">${nextDeliveryText}</td>
                </tr>
              </tbody>
            </table>
          </div>
        `;
      });

      resultsContainer.innerHTML = html;
      attachChannelRuleEvents();
    }

    // ============================================================
    // TOOLTIP HANDLING
    // ============================================================

    function attachChannelRuleEvents() {
      const triggers = document.querySelectorAll(".channel-rules-trigger");
      const tooltip = document.getElementById("channelTooltip");

      function positionTooltip(e) {
        const offset = 12;
        let x = e.clientX + offset;
        let y = e.clientY + offset;

        tooltip.style.left = x + "px";
        tooltip.style.top = y + "px";

        const rect = tooltip.getBoundingClientRect();
        if (rect.right > window.innerWidth - 10) {
          x = e.clientX - rect.width - offset;
          tooltip.style.left = x + "px";
        }
        if (rect.bottom > window.innerHeight - 10) {
          y = e.clientY - rect.height - offset;
          tooltip.style.top = y + "px";
        }
      }

      triggers.forEach(trigger => {
        trigger.addEventListener("mouseenter", e => {
          const channel = trigger.getAttribute("data-channel");
          const content = channelRules[channel] || "No rules defined for this channel.";
          tooltip.innerHTML = content;
          tooltip.style.display = "block";
          positionTooltip(e);
        });

        trigger.addEventListener("mousemove", positionTooltip);
        trigger.addEventListener("mouseleave", () => { tooltip.style.display = "none"; });
      });
    }

    // ============================================================
    // SEARCH HANDLING (FETCH ROUTES ON EACH SEARCH)
    // ============================================================

    function performSearch() {
      const input = document.getElementById("postcodeInput").value.trim();
      if (!input) {
        alert("Please enter a postcode or prefix.");
        return;
      }

      const cleaned = normaliseInputPostcode(input);
      const url = "routes.csv?cb=" + Date.now();

      fetch(url)
        .then(r => {
          if (!r.ok) throw new Error("Failed to load routes.csv");
          return r.text();
        })
        .then(text => {
          const routingData = parseRoutes(text);
          const bestPrefix = findBestMatchingPrefix(routingData, cleaned);

          if (!bestPrefix) {
            document.getElementById("resultsContainer").innerHTML = "";
            document.getElementById("resultsMeta").style.display = "none";
            document.getElementById("noResults").style.display = "block";
            return;
          }

          const matchingRows = routingData.filter(r => r.prefix === bestPrefix);
          buildResultsHTML(matchingRows, bestPrefix, input);
        })
        .catch(err => {
          console.error("Error loading routes.csv:", err);
          alert("Routing data is not available at the moment. Please try again in a moment or contact the system owner.");
        });
    }

    document.getElementById("searchButton").onclick = performSearch;
    document.getElementById("postcodeInput").addEventListener("keydown", e => {
      if (e.key === "Enter") { e.preventDefault(); performSearch(); }
    });

    // Load supporting CSVs once on page load
    loadChannelRules();
    loadBankHolidays();
  </script>
</body>
</html>



