<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Transport Route Checker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * {
      box-sizing: border-box;
      font-family: Arial, sans-serif;
    }

    body {
      margin: 0;
      padding: 20px;
      background: #f5f5f5;
      color: #222;
    }

    h1 {
      margin-top: 0;
      font-size: 24px;
      text-align: center;
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: #ffffff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    .search-section {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .search-section label {
      font-weight: bold;
    }

    .search-input-wrapper {
      flex: 1 1 200px;
      display: flex;
      gap: 8px;
    }

    input[type="text"] {
      flex: 1;
      padding: 8px 10px;
      font-size: 14px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      background: #0078d4;
      color: #fff;
    }

    button:hover {
      background: #005ea3;
    }

    .results-header {
      margin-top: 10px;
      font-size: 14px;
      font-weight: bold;
    }

    .no-results {
      margin-top: 10px;
      padding: 10px;
      border-radius: 5px;
      font-size: 13px;
      background: #ffe5e5;
      color: #a00;
    }

    .channel-block {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      background: #fafafa;
      border: 1px solid #e0e0e0;
    }

    .channel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .channel-title {
      font-size: 16px;
      font-weight: bold;
    }

    .channel-rules-trigger {
      font-size: 12px;
      color: #0078d4;
      text-decoration: underline;
      cursor: help;
      white-space: nowrap;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 5px;
      font-size: 13px;
      table-layout: fixed;
    }

    th, td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      text-align: left;
      overflow-wrap: break-word;
    }

    th {
      background: #f0f0f0;
      font-weight: bold;
    }

    .lead-time {
      white-space: nowrap;
    }

    #channelTooltip {
      position: fixed;
      z-index: 9999;
      max-width: 320px;
      padding: 10px;
      background: #ffffff;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      font-size: 12px;
      line-height: 1.4;
      display: none;
    }

    @media (max-width: 600px) {
      .search-section {
        flex-direction: column;
        align-items: flex-start;
      }
      .search-input-wrapper {
        width: 100%;
      }
      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Transport Route Checker</h1>

    <div class="search-section">
      <label for="postcodeInput">Postcode prefix:</label>
      <div class="search-input-wrapper">
        <input id="postcodeInput" type="text" placeholder="e.g. M34" autocomplete="off">
        <button id="searchButton">Search</button>
      </div>
    </div>

    <div id="resultsMeta" class="results-header" style="display:none;"></div>
    <div id="resultsContainer"></div>

    <div id="noResults" class="no-results" style="display:none;">
      No routing information found for that postcode prefix.
    </div>
  </div>

  <!-- Shared tooltip element -->
  <div id="channelTooltip"></div>

  <script>
    // ============================================================
    // CHANNEL RULES (LOADED FROM channel_rules.csv)
    // ============================================================

    let channelRules = {};     // channel -> HTML content
    let rulesLoaded = false;   // for diagnostics if needed

    function parseRulesCsv(text) {
      const lines = text.split(/\r?\n/).filter(line => line.trim() !== "");
      if (lines.length === 0) return {};

      const headers = lines[0].split(",").map(h => h.trim());
      const dataLines = lines.slice(1);
      const channelIndex = headers.indexOf("channel");
      const rulesIndex = headers.indexOf("rules");

      const result = {};

      dataLines.forEach(line => {
        const cols = line.split(",");
        const channel = (cols[channelIndex] || "").trim();
        const rulesCell = (cols[rulesIndex] || "").trim();

        if (!channel) return;

        const parts = rulesCell
          .split("|")
          .map(p => p.trim())
          .filter(Boolean);

        let html = `<strong>${channel} rules</strong>`;
        if (parts.length) {
          html += "<br>" + parts.map(p => "- " + p).join("<br>");
        }

        result[channel] = html;
      });

      return result;
    }

    function loadChannelRules() {
      fetch("channel_rules.csv")
        .then(response => {
          if (!response.ok) {
            throw new Error("Failed to load channel_rules.csv");
          }
          return response.text();
        })
        .then(text => {
          channelRules = parseRulesCsv(text);
          rulesLoaded = true;
        })
        .catch(err => {
          console.error("Error loading channel_rules.csv:", err);
          rulesLoaded = false;
          channelRules = {}; // fall back to "No rules defined" text
        });
    }

    // ============================================================
    // CSV PARSING FOR ROUTES
    // ============================================================

    function parseRoutesCsv(text) {
      const lines = text.split(/\r?\n/).filter(line => line.trim() !== "");
      if (lines.length === 0) return [];

      const headers = lines[0].split(",").map(h => h.trim());
      const dataLines = lines.slice(1);

      const result = dataLines.map(line => {
        const cols = line.split(",");
        const row = {};
        headers.forEach((h, i) => {
          row[h] = (cols[i] || "").trim();
        });

        const daysArray = (row.days || "")
          .split("|")
          .map(d => d.trim())
          .filter(Boolean);

        return {
          prefix: (row.prefix || "").toUpperCase().replace(/\s+/g, ""),
          route: row.route || "",
          channel: row.channel || "",
          serviceType: row.serviceType || "",
          leadTime: row.leadTime || "",
          days: daysArray
        };
      });

      return result;
    }

    // ============================================================
    // CORE HELPERS
    // ============================================================

    function normaliseInputPostcode(raw) {
      return raw ? raw.toUpperCase().replace(/\s+/g, "") : "";
    }

    function findBestMatchingPrefix(routingData, cleaned) {
      const prefixes = [...new Set(routingData.map(r => r.prefix))];
      const matches = prefixes.filter(p => cleaned.startsWith(p));
      return matches.sort((a, b) => b.length - a.length)[0] || null;
    }

    function groupByChannel(rows) {
      return rows.reduce((acc, r) => {
        acc[r.channel] = acc[r.channel] || [];
        acc[r.channel].push(r);
        return acc;
      }, {});
    }

    function sortDays(days) {
      const order = ["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"];
      return days.slice().sort((a, b) => {
        const aIndex = order.indexOf(String(a).toUpperCase());
        const bIndex = order.indexOf(String(b).toUpperCase());
        return aIndex - bIndex;
      });
    }

    function buildResultsHTML(rows, usedPrefix, originalInput) {
      const grouped = groupByChannel(rows);
      const channels = Object.keys(grouped).sort();
      const resultsContainer = document.getElementById("resultsContainer");
      const resultsMeta = document.getElementById("resultsMeta");
      const noResults = document.getElementById("noResults");

      if (!channels.length) {
        resultsMeta.style.display = "none";
        resultsContainer.innerHTML = "";
        noResults.style.display = "block";
        return;
      }

      noResults.style.display = "none";
      resultsMeta.style.display = "block";
      resultsMeta.textContent =
        `Results for postcode: ${originalInput || usedPrefix} (matched prefix: ${usedPrefix})`;

      let html = "";

      channels.forEach(channel => {
        const rowsForChannel = grouped[channel];

        const route = rowsForChannel[0].route;
        const serviceType = rowsForChannel[0].serviceType;
        const leadTime = rowsForChannel[0].leadTime;

        const allDays = sortDays(
          [...new Set(rowsForChannel.flatMap(r => r.days))]
        );

        html += `
          <div class="channel-block">
            <div class="channel-header">
              <div class="channel-title">${channel}</div>
              <div class="channel-rules-trigger" data-channel="${channel}">
                Hover here for channel rules
              </div>
            </div>
            <table>
              <colgroup>
                <col style="width: 25%">
                <col style="width: 35%">
                <col style="width: 20%">
                <col style="width: 20%">
              </colgroup>
              <thead>
                <tr>
                  <th>Route</th>
                  <th>Delivery Days</th>
                  <th>Delivery Type</th>
                  <th>Lead Time</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>${route}</td>
                  <td>${allDays.join(", ")}</td>
                  <td>${serviceType}</td>
                  <td class="lead-time">${leadTime}</td>
                </tr>
              </tbody>
            </table>
          </div>
        `;
      });

      resultsContainer.innerHTML = html;
      attachChannelRuleEvents();
    }

    // ============================================================
    // TOOLTIP HANDLING
    // ============================================================

    function attachChannelRuleEvents() {
      const triggers = document.querySelectorAll(".channel-rules-trigger");
      const tooltip = document.getElementById("channelTooltip");

      function positionTooltip(e) {
        const offset = 12;
        let x = e.clientX + offset;
        let y = e.clientY + offset;

        tooltip.style.left = x + "px";
        tooltip.style.top = y + "px";

        const rect = tooltip.getBoundingClientRect();
        if (rect.right > window.innerWidth - 10) {
          x = e.clientX - rect.width - offset;
          tooltip.style.left = x + "px";
        }
        if (rect.bottom > window.innerHeight - 10) {
          y = e.clientY - rect.height - offset;
          tooltip.style.top = y + "px";
        }
      }

      triggers.forEach(trigger => {
        trigger.addEventListener("mouseenter", e => {
          const channel = trigger.getAttribute("data-channel");
          const content = channelRules[channel] || "No rules defined for this channel.";
          tooltip.innerHTML = content;
          tooltip.style.display = "block";
          positionTooltip(e);
        });

        trigger.addEventListener("mousemove", positionTooltip);

        trigger.addEventListener("mouseleave", () => {
          tooltip.style.display = "none";
        });
      });
    }

    // ============================================================
    // SEARCH HANDLING (FETCH ROUTES ON EACH SEARCH)
    // ============================================================

    function performSearch() {
      const input = document.getElementById("postcodeInput").value.trim();
      if (!input) {
        alert("Please enter a postcode or prefix.");
        return;
      }

      const cleaned = normaliseInputPostcode(input);

      // cache-busting query param to avoid stale CSV
      const url = "routes.csv?cb=" + Date.now();

      fetch(url)
        .then(response => {
          if (!response.ok) {
            throw new Error("Failed to load routes.csv");
          }
          return response.text();
        })
        .then(text => {
          const routingData = parseRoutesCsv(text);
          const bestPrefix = findBestMatchingPrefix(routingData, cleaned);

          if (!bestPrefix) {
            document.getElementById("resultsContainer").innerHTML = "";
            document.getElementById("resultsMeta").style.display = "none";
            document.getElementById("noResults").style.display = "block";
            return;
          }

          const matchingRows = routingData.filter(r => r.prefix === bestPrefix);
          buildResultsHTML(matchingRows, bestPrefix, input);
        })
        .catch(err => {
          console.error("Error loading routes.csv:", err);
          alert("Routing data is not available at the moment. Please try again in a moment or contact the system owner.");
        });
    }

    document.getElementById("searchButton").onclick = performSearch;
    document.getElementById("postcodeInput").addEventListener("keydown", e => {
      if (e.key === "Enter") {
        e.preventDefault();
        performSearch();
      }
    });

    // Load channel rules once on page load
    loadChannelRules();
  </script>
</body>
</html>
