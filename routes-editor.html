<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Routes Editor</title>
  <style>
    * { box-sizing: border-box; font-family: Arial, sans-serif; }
    body { margin: 0; padding: 18px; background:#f5f5f5; color:#222; }
    .wrap { max-width: 1200px; margin:0 auto; background:#fff; padding:16px; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,.08); }
    h1 { margin: 0 0 12px; font-size: 22px; }
    .row { display:flex; flex-wrap:wrap; gap:10px; align-items:flex-end; margin: 10px 0; }
    .group { background:#fafafa; border:1px solid #e6e6e6; border-radius:10px; padding:12px; }
    label { font-size: 12px; font-weight: bold; display:block; margin-bottom: 4px; }
    input[type="text"], select {
      padding: 8px 10px; border:1px solid #ccc; border-radius:6px; font-size: 13px; width: 220px;
    }
    .small { width: 150px !important; }
    .wide { width: 320px !important; }
    button {
      padding: 9px 12px; border:0; border-radius:6px; background:#0078d4; color:#fff; cursor:pointer; font-size: 13px;
    }
    button:hover { background:#005ea3; }
    button:disabled { background:#9bbbd7; cursor:not-allowed; }
    .muted { font-size: 12px; color:#666; }
    .status { font-size: 12px; padding:8px 10px; border-radius:6px; background:#f0f7ff; border:1px solid #d6eaff; }
    .status.bad { background:#ffecec; border-color:#ffd0d0; color:#900; }

    table { width:100%; border-collapse: collapse; margin-top: 10px; table-layout: fixed; background:#fff; }
    th, td { border:1px solid #e2e2e2; padding: 7px 8px; font-size: 13px; text-align:left; vertical-align: top; }
    th { background:#f2f2f2; position: sticky; top: 0; z-index: 1; }
    .col-check { width: 44px; text-align:center; }
    .col-prefix { width: 110px; }
    .col-route { width: 260px; }
    .col-channel { width: 180px; }
    .col-service { width: 140px; }
    .col-lead { width: 120px; }
    .col-days { width: 260px; }

    .cell-edit { border-radius: 4px; outline: none; min-height: 18px; }
    .cell-edit:focus { box-shadow: inset 0 0 0 2px rgba(0,120,212,.25); background:#fbfdff; }
    .invalid { background:#fff2f2 !important; box-shadow: inset 0 0 0 2px rgba(200,0,0,.2) !important; }

    .pill {
      display:inline-block; font-size: 11px; padding: 3px 8px; border-radius:999px;
      background:#f0f0f0; border:1px solid #e0e0e0; margin-left: 8px;
    }
    .toolbar-right { margin-left:auto; display:flex; gap:10px; align-items:center; }
    .hint { font-size: 12px; color:#555; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size: 11px; background:#f2f2f2; border:1px solid #ddd; border-bottom-width:2px; padding: 1px 5px; border-radius: 5px; }

    .preview {
      margin-left: auto;
      display:flex;
      align-items:center;
      gap:10px;
      padding: 8px 10px;
      border: 1px solid #e6e6e6;
      border-radius: 10px;
      background: #fff;
      min-height: 40px;
    }
    .preview strong { font-size: 12px; }
    .preview .count { font-size: 16px; font-weight: 700; }
    .preview .smalltxt { font-size: 12px; color:#666; }
    .preview.bad { border-color:#ffd0d0; background:#fff6f6; }
    .mini-btn { background:#444 !important; padding: 7px 10px !important; }
    .mini-btn:hover { background:#333 !important; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Routes Editor <span class="pill">routes.csv</span></h1>

    <div class="row">
      <div class="status" id="statusBox">Ready.</div>
      <div class="toolbar-right">
        <button id="reloadBtn">Reload routes.csv</button>
        <button id="downloadBtn" disabled>Download updated routes.csv</button>
      </div>
    </div>

    <div class="group">
      <div class="row">
        <div>
          <label>Quick filter: prefix contains</label>
          <input id="filterPrefix" type="text" placeholder="e.g. CO" class="small"/>
        </div>
        <div>
          <label>Quick filter: channel contains</label>
          <input id="filterChannel" type="text" placeholder="e.g. Component" class="wide"/>
        </div>
        <div>
          <label>Quick filter: route contains</label>
          <input id="filterRoute" type="text" placeholder="e.g. TKC19" class="wide"/>
        </div>
        <div>
          <button id="applyFiltersBtn">Apply filters</button>
        </div>
        <div class="muted">
          Tip: inline edit like Excel. Click a cell → type → <span class="kbd">Enter</span> commit, <span class="kbd">Esc</span> revert.
        </div>
      </div>
    </div>

    <div class="group" style="margin-top:12px;">
      <div class="row" style="align-items:flex-start;">
        <div style="min-width:280px;">
          <div class="hint"><strong>Bulk target</strong></div>
          <div class="muted">Choose what rows your bulk update applies to.</div>
        </div>

        <div>
          <label>Mode</label>
          <select id="bulkTargetMode">
            <option value="selected">Apply to ticked rows</option>
            <option value="range">Apply to prefix range</option>
            <option value="filtered">Apply to filtered results</option>
          </select>
        </div>

        <div>
          <label>From prefix</label>
          <input id="rangeFrom" type="text" placeholder="e.g. CO1 or CO" class="small"/>
        </div>

        <div>
          <label>To prefix</label>
          <input id="rangeTo" type="text" placeholder="e.g. CO15 or CV" class="small"/>
        </div>

        <div class="preview" id="previewBox">
          <div>
            <strong>Bulk preview</strong><br>
            <span class="smalltxt" id="previewModeText">Mode: ticked rows</span>
          </div>
          <div style="text-align:right;">
            <div class="count" id="previewCount">0</div>
            <div class="smalltxt" id="previewDetail">rows matched</div>
          </div>
          <button class="mini-btn" id="previewRefreshBtn" type="button">Refresh</button>
        </div>
      </div>

      <div class="muted" style="margin-top:8px;">
        Prefix range supports:
        <span class="kbd">CO1 → CO15</span>,
        <span class="kbd">CO → CO</span> (all CO*),
        <span class="kbd">CO → CV</span> (letter range),
        <span class="kbd">M → M34</span>,
        <span class="kbd">CO10 → CO</span> (CO10+).
      </div>

      <hr style="border:0; border-top:1px solid #e8e8e8; margin:10px 0;"/>

      <div class="row">
        <div style="min-width:200px;">
          <div class="hint"><strong>Bulk update fields</strong></div>
          <div class="muted">Leave blank = no change</div>
        </div>

        <div>
          <label>Route</label>
          <input id="bulkRoute" type="text" placeholder="e.g. TKC19 Colchester O/N" class="wide"/>
        </div>

        <div>
          <label>Channel</label>
          <input id="bulkChannel" type="text" placeholder="e.g. Component Channel" class="wide"/>
        </div>

        <div>
          <label>Delivery Type</label>
          <select id="bulkServiceType">
            <option value="">(no change)</option>
            <option>One-person</option>
            <option>Two-person</option>
          </select>
        </div>

        <div>
          <label>Lead Time</label>
          <input id="bulkLeadTime" type="text" placeholder="e.g. 5 Days" class="small"/>
        </div>

        <div>
          <label>Delivery Days (pipe separated)</label>
          <input id="bulkDays" type="text" placeholder="e.g. Monday|Wednesday|Friday" class="wide"/>
        </div>

        <div>
          <button id="applyBulkBtn">Apply bulk update</button>
        </div>
      </div>

      <div class="row">
        <div class="muted">
          <strong>Bulk actions:</strong>
          <button id="tickAllVisibleBtn" style="background:#444;">Tick all visible</button>
          <button id="untickAllVisibleBtn" style="background:#666;">Untick all visible</button>
          <button id="deleteSelectedBtn" style="background:#b00020;">Delete ticked rows</button>
          <button id="addRowBtn" style="background:#1a7f37;">Add new row</button>
        </div>
      </div>
    </div>

    <div style="margin-top:12px; overflow:auto; border-radius:10px; border:1px solid #e6e6e6;">
      <table>
        <thead>
          <tr>
            <th class="col-check"><input id="masterCheck" type="checkbox" title="Tick/untick visible rows"/></th>
            <th class="col-prefix">Prefix</th>
            <th class="col-route">Route</th>
            <th class="col-channel">Channel</th>
            <th class="col-service">Delivery Type</th>
            <th class="col-lead">Lead Time</th>
            <th class="col-days">Delivery Days (pipe)</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <div class="muted" style="margin-top:10px;">
      <strong>Notes:</strong> Editor outputs:
      <span class="kbd">prefix,route,channel,serviceType,leadTime,days</span>
      and <span class="kbd">days</span> is pipe-separated (e.g. Monday|Wednesday|Friday).
    </div>
  </div>

  <script>
    // ============================================================
    // BASIC CSV/TSV PARSING (auto-detect delimiter)
    // ============================================================

    function stripBom(s) {
      return s && s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;
    }

    function detectDelimiter(headerLine) {
      if (headerLine.includes("\t")) return "\t";
      return ",";
    }

    function splitLine(line, delim) {
      // Simple split – avoid commas/tabs inside values.
      return line.split(delim).map(x => x.trim());
    }

    function parseDelimited(text) {
      const cleanedText = stripBom(String(text || ""));
      const lines = cleanedText.split(/\r?\n/).filter(l => l.trim() !== "");
      if (!lines.length) return { delim: ",", headers: [], rows: [] };

      const delim = detectDelimiter(lines[0]);
      const headers = splitLine(lines[0], delim);

      const rows = [];
      for (const line of lines.slice(1)) {
        const cols = splitLine(line, delim);
        const obj = {};
        headers.forEach((h, i) => obj[h] = (cols[i] || ""));
        rows.push(obj);
      }
      return { delim, headers, rows };
    }

    function toCsvSafe(value) {
      return String(value ?? "").replace(/\r?\n/g, " ").trim();
    }

    // ============================================================
    // DATA MODEL
    // ============================================================

    let routes = [];   // full dataset
    let view = [];     // filtered + sorted view (array of {row, idx})
    let dirty = false;

    const headersOut = ["prefix","route","channel","serviceType","leadTime","days"];

    function normalisePrefix(v) {
      return String(v || "").toUpperCase().replace(/\s+/g, "").trim();
    }

    const weekdaySet = new Set(["monday","tuesday","wednesday","thursday","friday","saturday","sunday"]);

    function normaliseDaysPipe(daysPipe) {
      const parts = String(daysPipe || "")
        .split("|")
        .map(s => s.trim())
        .filter(Boolean);

      const valid = [];
      for (const p of parts) {
        const lower = p.toLowerCase();
        if (weekdaySet.has(lower)) {
          valid.push(lower.charAt(0).toUpperCase() + lower.slice(1));
        } else {
          valid.push(p);
        }
      }
      return valid.join("|");
    }

    function isDaysPipeValid(daysPipe) {
      const parts = String(daysPipe || "").split("|").map(s => s.trim()).filter(Boolean);
      if (!parts.length) return false;
      return parts.every(p => weekdaySet.has(p.toLowerCase()));
    }

    // ============================================================
    // EXTENDED PREFIX RANGE MATCHER
    // Supports:
    // - CO1 -> CO15
    // - CO -> CO (all CO*)
    // - CO -> CV (letter range)
    // - M -> M34 (mixed)
    // - CO10 -> CO (CO10+)
    // ============================================================

    function splitPrefix(p) {
      const s = normalisePrefix(p);
      const m = s.match(/^([A-Z]+)(\d+)?$/);
      if (!m) return { letters: s, num: null, raw: s };
      return { letters: m[1], num: m[2] ? parseInt(m[2], 10) : null, raw: s };
    }

    function cmpLetters(aLetters, bLetters) {
      return String(aLetters || "").localeCompare(String(bLetters || ""));
    }

    function prefixInRange(prefix, fromP, toP) {
      const p = splitPrefix(prefix);
      const a = splitPrefix(fromP);
      const b = splitPrefix(toP);

      if (!p.letters || !a.letters || !b.letters) return false;

      // Normalise direction
      let from = a, to = b;
      const letterCmp = cmpLetters(from.letters, to.letters);
      if (letterCmp > 0) { from = b; to = a; }
      else if (letterCmp === 0) {
        // same letters: normalise numeric direction too
        const fromNum = from.num ?? -Infinity;
        const toNum = to.num ?? Infinity;
        if (fromNum > toNum) { const tmp = from; from = to; to = tmp; }
      }

      // Letter-range check
      const lettersOK =
        cmpLetters(p.letters, from.letters) >= 0 &&
        cmpLetters(p.letters, to.letters) <= 0;

      if (!lettersOK) return false;

      // If letters are strictly between boundaries, include whole letters block
      if (p.letters !== from.letters && p.letters !== to.letters) return true;

      // On boundary letters, apply numeric constraints if present
      const pNum = (p.num === null) ? 0 : p.num;

      if (p.letters === from.letters && from.num !== null) {
        if (pNum < from.num) return false;
      }

      if (p.letters === to.letters && to.num !== null) {
        if (pNum > to.num) return false;
      }

      return true;
    }

    // ============================================================
    // LOAD / SAVE
    // ============================================================

    const statusBox = document.getElementById("statusBox");
    const reloadBtn = document.getElementById("reloadBtn");
    const downloadBtn = document.getElementById("downloadBtn");

    function setStatus(msg, bad=false) {
      statusBox.textContent = msg;
      statusBox.classList.toggle("bad", !!bad);
    }

    function markDirty() {
      dirty = true;
      downloadBtn.disabled = false;
    }

    async function loadRoutesCsv() {
      setStatus("Loading routes.csv…");
      downloadBtn.disabled = true;
      dirty = false;

      const url = "routes.csv?cb=" + Date.now();
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Failed to load routes.csv");

      const text = await resp.text();
      const parsed = parseDelimited(text);

      routes = parsed.rows.map(r => ({
        prefix: normalisePrefix(r.prefix),
        route: String(r.route || "").trim(),
        channel: String(r.channel || "").trim(),
        serviceType: String(r.serviceType || "").trim(),
        leadTime: String(r.leadTime || "").trim(),
        days: normaliseDaysPipe(r.days || "")
      })).filter(r => r.prefix && r.channel);

      setStatus(`Loaded ${routes.length.toLocaleString()} rows.`);
      render();
      updatePreview();
    }

    function downloadUpdatedCsv() {
      const lines = [];
      lines.push(headersOut.join(","));

      for (const r of routes) {
        lines.push([
          toCsvSafe(r.prefix),
          toCsvSafe(r.route),
          toCsvSafe(r.channel),
          toCsvSafe(r.serviceType),
          toCsvSafe(r.leadTime),
          toCsvSafe(normaliseDaysPipe(r.days))
        ].join(","));
      }

      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "routes.csv";
      a.click();
      URL.revokeObjectURL(url);

      setStatus("Downloaded updated routes.csv (commit it back to GitHub).");
    }

    // ============================================================
    // FILTER + SORT (postcode order)
    // ============================================================

    const filterPrefix = document.getElementById("filterPrefix");
    const filterChannel = document.getElementById("filterChannel");
    const filterRoute = document.getElementById("filterRoute");
    const applyFiltersBtn = document.getElementById("applyFiltersBtn");

    function passesFilters(r) {
      const fp = filterPrefix.value.trim().toUpperCase();
      const fc = filterChannel.value.trim().toLowerCase();
      const fr = filterRoute.value.trim().toLowerCase();

      if (fp && !r.prefix.includes(fp)) return false;
      if (fc && !r.channel.toLowerCase().includes(fc)) return false;
      if (fr && !r.route.toLowerCase().includes(fr)) return false;
      return true;
    }

    function sortByPrefixThenChannel(a, b) {
      if (a.prefix !== b.prefix) return a.prefix.localeCompare(b.prefix);
      return a.channel.localeCompare(b.channel);
    }

    // ============================================================
    // RENDER TABLE + INLINE EDITING
    // ============================================================

    const tbody = document.getElementById("tbody");
    const masterCheck = document.getElementById("masterCheck");

    function render() {
      view = routes
        .map((row, idx) => ({ row, idx }))
        .filter(x => passesFilters(x.row))
        .sort((x, y) => sortByPrefixThenChannel(x.row, y.row));

      tbody.innerHTML = "";

      for (const item of view) {
        const r = item.row;
        const tr = document.createElement("tr");

        const tdC = document.createElement("td");
        tdC.className = "col-check";
        tdC.innerHTML = `<input type="checkbox" class="rowCheck" data-idx="${item.idx}">`;
        tr.appendChild(tdC);

        tr.appendChild(makeEditableCell(item.idx, "prefix", r.prefix, "col-prefix", { upper:true, validatePrefix:true }));
        tr.appendChild(makeEditableCell(item.idx, "route", r.route, "col-route"));
        tr.appendChild(makeEditableCell(item.idx, "channel", r.channel, "col-channel"));
        tr.appendChild(makeEditableCell(item.idx, "serviceType", r.serviceType, "col-service"));
        tr.appendChild(makeEditableCell(item.idx, "leadTime", r.leadTime, "col-lead"));
        tr.appendChild(makeEditableCell(item.idx, "days", r.days, "col-days", { validateDays:true }));

        tbody.appendChild(tr);
      }

      masterCheck.checked = false;
      setStatus(`Showing ${view.length.toLocaleString()} of ${routes.length.toLocaleString()} rows.`);
    }

    function makeEditableCell(routeIdx, field, value, className, opts={}) {
      const td = document.createElement("td");
      td.className = className;

      const div = document.createElement("div");
      div.className = "cell-edit";
      div.contentEditable = "true";
      div.spellcheck = false;
      div.dataset.idx = routeIdx;
      div.dataset.field = field;
      div.textContent = value ?? "";

      let original = div.textContent;

      function validateCurrent() {
        div.classList.remove("invalid");

        if (opts.validateDays) {
          const v = div.textContent.trim();
          if (!isDaysPipeValid(v)) div.classList.add("invalid");
        }
        if (opts.validatePrefix) {
          const v = normalisePrefix(div.textContent);
          if (!/^[A-Z]{1,4}\d{0,4}$/.test(v)) div.classList.add("invalid");
        }
      }

      div.addEventListener("focus", () => { original = div.textContent; });

      div.addEventListener("input", validateCurrent);

      div.addEventListener("keydown", (e) => {
        if (e.key === "Enter") { e.preventDefault(); div.blur(); }
        if (e.key === "Escape") {
          e.preventDefault();
          div.textContent = original;
          validateCurrent();
          div.blur();
        }
      });

      div.addEventListener("blur", () => {
        let v = div.textContent;

        if (opts.upper) v = v.toUpperCase();
        v = v.trim();

        if (field === "prefix") v = normalisePrefix(v);
        if (field === "days") v = normaliseDaysPipe(v);

        if (div.textContent !== v) div.textContent = v;

        validateCurrent();

        if (v !== (routes[routeIdx][field] ?? "")) {
          if (div.classList.contains("invalid")) {
            div.textContent = routes[routeIdx][field] ?? "";
            div.classList.remove("invalid");
            return;
          }
          routes[routeIdx][field] = v;
          markDirty();
          updatePreview(); // selection count may depend on prefixes
        }
      });

      td.appendChild(div);
      return td;
    }

    // ============================================================
    // SELECTION HELPERS
    // ============================================================

    function getCheckedIndexes() {
      return Array.from(document.querySelectorAll(".rowCheck:checked"))
        .map(cb => Number(cb.dataset.idx))
        .filter(n => Number.isFinite(n));
    }

    function setAllVisibleChecks(checked) {
      document.querySelectorAll(".rowCheck").forEach(cb => cb.checked = checked);
      masterCheck.checked = checked;
      updatePreview();
    }

    masterCheck.addEventListener("change", () => setAllVisibleChecks(masterCheck.checked));

    document.getElementById("tickAllVisibleBtn").addEventListener("click", () => setAllVisibleChecks(true));
    document.getElementById("untickAllVisibleBtn").addEventListener("click", () => setAllVisibleChecks(false));

    // ============================================================
    // BULK UPDATE (selected / prefix-range / filtered)
    // ============================================================

    const bulkTargetMode = document.getElementById("bulkTargetMode");
    const rangeFrom = document.getElementById("rangeFrom");
    const rangeTo = document.getElementById("rangeTo");

    const bulkRoute = document.getElementById("bulkRoute");
    const bulkChannel = document.getElementById("bulkChannel");
    const bulkServiceType = document.getElementById("bulkServiceType");
    const bulkLeadTime = document.getElementById("bulkLeadTime");
    const bulkDays = document.getElementById("bulkDays");

    function isValidPrefixToken(s) {
      const v = normalisePrefix(s);
      return /^[A-Z]+(\d+)?$/.test(v);
    }

    function getBulkTargets(modeOverride=null) {
      const mode = modeOverride || bulkTargetMode.value;

      if (mode === "selected") return getCheckedIndexes();

      if (mode === "filtered") return view.map(v => v.idx);

      if (mode === "range") {
        const fromP = rangeFrom.value.trim();
        const toP = rangeTo.value.trim();
        if (!fromP || !toP) return [];

        const fromN = normalisePrefix(fromP);
        const toN = normalisePrefix(toP);

        if (!isValidPrefixToken(fromN) || !isValidPrefixToken(toN)) return [];

        const targets = [];
        for (let i = 0; i < routes.length; i++) {
          if (prefixInRange(routes[i].prefix, fromN, toN)) targets.push(i);
        }
        return targets;
      }

      return [];
    }

    function applyBulkUpdate() {
      const mode = bulkTargetMode.value;
      const targets = getBulkTargets(mode);

      if (!targets.length) {
        alert("No target rows found for the chosen bulk mode.");
        return;
      }

      if (mode === "range") {
        const fromP = rangeFrom.value.trim();
        const toP = rangeTo.value.trim();
        if (!fromP || !toP) {
          alert("Enter both From prefix and To prefix for prefix-range mode.");
          return;
        }
        if (!isValidPrefixToken(fromP) || !isValidPrefixToken(toP)) {
          alert("Prefix range must be letters with optional numbers (e.g. CO, CO10, M, M34).");
          return;
        }
      }

      const routeVal = bulkRoute.value.trim();
      const channelVal = bulkChannel.value.trim();
      const serviceVal = bulkServiceType.value;
      const leadVal = bulkLeadTime.value.trim();
      const daysValRaw = bulkDays.value.trim();
      const daysVal = daysValRaw ? normaliseDaysPipe(daysValRaw) : "";

      if (daysValRaw && !isDaysPipeValid(daysValRaw)) {
        alert("Delivery Days must be pipe-separated weekdays, e.g. Monday|Wednesday|Friday");
        return;
      }

      if (!routeVal && !channelVal && !serviceVal && !leadVal && !daysValRaw) {
        alert("No bulk fields entered (nothing to change).");
        return;
      }

      targets.forEach(idx => {
        const r = routes[idx];
        if (routeVal) r.route = routeVal;
        if (channelVal) r.channel = channelVal;
        if (serviceVal) r.serviceType = serviceVal;
        if (leadVal) r.leadTime = leadVal;
        if (daysValRaw) r.days = daysVal;
      });

      markDirty();
      render();
      updatePreview();
      setStatus(`Bulk update applied to ${targets.length.toLocaleString()} rows.`);
    }

    document.getElementById("applyBulkBtn").addEventListener("click", applyBulkUpdate);

    // ============================================================
    // DELETE + ADD ROW
    // ============================================================

    document.getElementById("deleteSelectedBtn").addEventListener("click", () => {
      const idxs = getCheckedIndexes();
      if (!idxs.length) { alert("No rows ticked."); return; }
      if (!confirm(`Delete ${idxs.length} rows? This can’t be undone (until you reload).`)) return;

      idxs.sort((a,b)=>b-a).forEach(i => routes.splice(i,1));
      markDirty();
      render();
      updatePreview();
      setStatus(`Deleted ${idxs.length} rows.`);
    });

    document.getElementById("addRowBtn").addEventListener("click", () => {
      routes.push({
        prefix: "",
        route: "",
        channel: "",
        serviceType: "",
        leadTime: "",
        days: "Monday"
      });
      markDirty();
      render();
      updatePreview();
      setStatus("Added a new row at the end (scroll to find it, then edit).");
    });

    // ============================================================
    // PREVIEW COUNT
    // ============================================================

    const previewBox = document.getElementById("previewBox");
    const previewModeText = document.getElementById("previewModeText");
    const previewCount = document.getElementById("previewCount");
    const previewDetail = document.getElementById("previewDetail");
    const previewRefreshBtn = document.getElementById("previewRefreshBtn");

    function updatePreview() {
      const mode = bulkTargetMode.value;
      let targets = [];
      let detail = "rows matched";
      let bad = false;

      if (mode === "selected") {
        targets = getBulkTargets("selected");
        previewModeText.textContent = "Mode: ticked rows";
        detail = "ticked rows";
      } else if (mode === "filtered") {
        targets = getBulkTargets("filtered");
        previewModeText.textContent = "Mode: filtered results";
        detail = "visible rows";
      } else if (mode === "range") {
        const fromP = rangeFrom.value.trim();
        const toP = rangeTo.value.trim();
        previewModeText.textContent = "Mode: prefix range";
        detail = "rows in range";

        if (!fromP || !toP) {
          targets = [];
          bad = true;
          detail = "enter From + To";
        } else if (!isValidPrefixToken(fromP) || !isValidPrefixToken(toP)) {
          targets = [];
          bad = true;
          detail = "invalid range format";
        } else {
          targets = getBulkTargets("range");
        }
      }

      previewCount.textContent = targets.length.toLocaleString();
      previewDetail.textContent = detail;
      previewBox.classList.toggle("bad", bad);
    }

    previewRefreshBtn.addEventListener("click", updatePreview);

    // Update preview when ticks change
    document.addEventListener("change", (e) => {
      if (e.target && e.target.classList && e.target.classList.contains("rowCheck")) {
        updatePreview();
      }
    });

    bulkTargetMode.addEventListener("change", updatePreview);
    rangeFrom.addEventListener("input", updatePreview);
    rangeTo.addEventListener("input", updatePreview);

    // ============================================================
    // UI EVENTS
    // ============================================================

    applyFiltersBtn.addEventListener("click", () => { render(); updatePreview(); });

    filterPrefix.addEventListener("keydown", (e) => { if (e.key === "Enter") { render(); updatePreview(); }});
    filterChannel.addEventListener("keydown", (e) => { if (e.key === "Enter") { render(); updatePreview(); }});
    filterRoute.addEventListener("keydown", (e) => { if (e.key === "Enter") { render(); updatePreview(); }});

    reloadBtn.addEventListener("click", async () => {
      if (dirty && !confirm("You have unsaved changes (not downloaded). Reload anyway?")) return;
      try { await loadRoutesCsv(); }
      catch (e) { console.error(e); setStatus(String(e.message || e), true); }
    });

    downloadBtn.addEventListener("click", downloadUpdatedCsv);

    // ============================================================
    // INIT
    // ============================================================

    (async function init() {
      downloadBtn.disabled = true;
      try {
        await loadRoutesCsv();
      } catch (e) {
        console.error(e);
        setStatus("Failed to load routes.csv. Ensure routes-editor.html and routes.csv are in the same GitHub Pages folder.", true);
      }
    })();
  </script>
</body>
</html>
