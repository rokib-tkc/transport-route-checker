<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Transport Team Admin</title>
  <style>
    :root{
      --border:#cfcfcf;
      --header:#efefef;
      --routecol:#e6e6e6;
      --inactive:#f7f7f7;

      --green:#00b050;
      --red:#ff0000;
      --orange:#ffc000;

      --text:#111;
    }

    *{ box-sizing: border-box; font-family: Arial, sans-serif; }

    /* Keep your original admin layout behaviour */
    body{
      font-family: Arial, sans-serif;
      margin: 18px;
      color: var(--text);
      background: #fff;
    }

    /* ---------- TOKEN GATE ---------- */
    .gateWrap{
      max-width: 520px;
      margin: 0 auto;
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px 16px 14px;
      background: #fff;
    }
    .gateRow{
      display:flex;
      gap:10px;
      align-items:center;
      margin-top:12px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .gateRow input{
      flex: 1;
      min-width: 240px;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid #bbb;
      font-size: 14px;
    }

    /* ---------- TOP LAYOUT ---------- */
    .top{
      max-width: 1400px;
      margin: 0 auto 10px;
      text-align: center;
    }
    h1{
      margin: 0 0 8px;
      font-size: 24px;
      font-weight: 800;
      letter-spacing: .2px;
    }

    .btn{
      padding: 10px 12px;
      cursor: pointer;
      border: 1px solid #bbb;
      background: #fff;
      border-radius: 10px;
      font-weight: 700;
      font-size: 14px;
    }
    .btn:disabled{opacity:.55;cursor:not-allowed}

    .bar{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;
      margin: 0 0 10px;
    }

    .status{
      margin: 0 auto 12px;
      font-size: 13px;
      color: #333;
      min-height: 18px;
    }

    /* ---------- LEGEND ---------- */
    .legend{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;
      margin: 14px 0 10px;
      font-size: 13px;
    }
    .chip{display:inline-flex;align-items:center;gap:6px}
    .dot{width:12px;height:12px;border-radius:3px;display:inline-block;border:1px solid #999}

    /* ---------- TABLE (typography aligned to Route Checker) ---------- */
    .wrap{
      max-width: 1400px;
      margin: 0 auto;
      border: 1px solid #ccc;
      border-radius: 12px;
      overflow: visible; /* IMPORTANT: must remain visible for sticky header reliability */
      background: #fff;
    }

    table{
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;
      min-width: 0;

      /* IMPORTANT: do NOT set overflow:hidden on table (breaks sticky in many browsers) */
      font-size: 13px; /* matches route checker */
    }

    th, td{
      border: 1px solid #ddd;   /* route checker uses #ddd */
      padding: 6px 8px;         /* route checker spacing */
      text-align: center;
      vertical-align: middle;
      height: 34px;
      font-size: 13px;
      line-height: 1.25;
      overflow-wrap: break-word;
      word-break: break-word;
      white-space: normal;
      font-weight: 400;
    }

    th{
      background: #f0f0f0; /* route checker header */
      font-weight: 700;
      line-height: 1.15;
      font-size: 13px;
    }

    /* ---------- STICKY HEADER ROW (sticks to top of the page) ---------- */
    thead th{
      position: sticky;
      top: 0;       /* sticks under browser UI/address bar */
      z-index: 20;  /* above body cells */
    }

    /* Route column (sticky) */
    th.routeHead, td.routeCell{
      width: 230px;
    }

    .routeCell{
      background: var(--routecol);
      font-weight: 700;
      text-align: left;
      position: sticky;
      left: 0;
      z-index: 10;
      overflow: visible;
    }
    th.routeHead{
      position: sticky;
      left: 0;
      z-index: 30;
    }

    .inactive{background: var(--inactive)}
    .runAvailable{background: var(--green)}
    .fullWeight{background: var(--red); color:#fff}
    .fullDrops{background: var(--orange)}
    .pendingOutline{outline:3px solid #00000022;outline-offset:-3px}

    select{
      width: 100%;
      border: 0;
      background: transparent;
      font-weight: 600;
      cursor: pointer;
      appearance: none;
      text-align: center;
      text-align-last: center;
      white-space: normal;
      word-break: break-word;
      line-height: 1.2;
      font-size: 13px;
      padding: 0;
    }
    select:focus{outline: 2px solid #00000015; outline-offset: 2px;}

    /* ---------- ROUTE TOOLTIP ---------- */
    .routeName{
      position: relative;
      display: inline-block;
      max-width: 100%;
      cursor: help;
    }
    .routeTooltip{
      position: absolute;
      left: 0;
      top: calc(100% + 8px);
      z-index: 9999;

      min-width: 280px;
      max-width: 520px;

      background: #fff;
      border: 1px solid #ddd;
      border-radius: 10px;
      padding: 10px 12px;

      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      text-align: left;

      opacity: 0;
      transform: translateY(-4px);
      pointer-events: none;
      transition: opacity .12s ease, transform .12s ease;

      font-size: 12px;
      line-height: 1.4;
      color: #111;

      white-space: normal;
      word-break: break-word;
    }
    .routeName:hover .routeTooltip{
      opacity: 1;
      transform: translateY(0);
    }
    .routeTooltipTitle{
      font-weight: 700;
      margin-bottom: 6px;
      font-size: 12px;
    }
    .routeTooltipBody{
      font-weight: 600;
      color: #333;
    }

    /* ---------- TOOLTIP LAYER FIX (keep tooltip above rows below) ---------- */
    tbody{
      position: relative;
      z-index: 1;
    }
    tbody tr:hover{
      position: relative;
      z-index: 50;
    }
    td.routeCell:hover{
      z-index: 200;
    }
    .routeName:hover{
      z-index: 300;
    }

    /* ---------- HIDE/SHOW ---------- */
    .hidden{display:none !important;}

    @media (max-width: 1100px){
      th, td{font-size: 12px}
      th{font-size: 12px}
      select{font-size: 12px}
      th.routeHead, td.routeCell{width: 210px}
      .routeTooltip{min-width: 240px; max-width: 360px;}
    }
  </style>
</head>
<body>

  <div class="top">
    <h1>Transport Team Admin</h1>
    <div class="status" id="status">Ready.</div>

    <div class="bar hidden" id="controls">
      <button class="btn" id="reloadBtn">Reload</button>
      <button class="btn" id="discardBtn" disabled>Discard pending</button>
      <button class="btn" id="saveBtn" disabled>Save changes</button>
    </div>
  </div>

  <!-- TOKEN GATE -->
  <div id="gate" class="gateWrap">
    <div style="font-size:13px;color:#444;line-height:1.4;text-align:center">
      Enter the admin token to access the transport status editor.
    </div>

    <div class="gateRow">
      <input id="gateToken" type="password" placeholder="Admin token" autocomplete="off" />
      <button id="proceedBtn" class="btn">Proceed</button>
    </div>

    <div id="gateMsg" style="margin-top:10px;font-size:13px;color:#333;line-height:1.35;text-align:center">
      Token is required each time the page loads.
    </div>
  </div>

  <!-- APP UI -->
  <div id="app" class="hidden">
    <div class="legend">
      <span class="chip"><span class="dot" style="background:var(--green)"></span> Available (scheduled run)</span>
      <span class="chip"><span class="dot" style="background:var(--red)"></span> Full - On Weight</span>
      <span class="chip"><span class="dot" style="background:var(--orange)"></span> Full - On Drops</span>
      <span class="chip"><span class="dot" style="background:var(--inactive)"></span> Not a run day</span>
    </div>

    <div class="wrap">
      <table id="grid"></table>
    </div>
  </div>

  <script>
    const CONFIG = {
      API_URL: "https://script.google.com/macros/s/AKfycbz4A-9fYDa5hbzvP_LxCka1Mwxfg8MYQj4lwKx1oPFRWBC2PX71z64neOFmpBgjDD8oAw/exec",
      ROUTES_CSV_URL: "./routes.csv",
      BANK_HOLIDAYS_CSV_URL: "./bank_holidays.csv",
      DAYS_AHEAD: 10
    };

    const STATUS = {
      AVAILABLE: "Available",
      FULL_WEIGHT: "Full - On Weight",
      FULL_DROPS: "Full - On Drops"
    };

    let sessionToken = "";
    const pending = new Map();
    const overrides = new Map();
    const schedule = new Map();
    const bankHolidays = new Set();
    let dateCols = [];
    const cellByKey = new Map();

    const routePostcodeGroups = new Map();

    const gateEl = document.getElementById("gate");
    const appEl = document.getElementById("app");
    const controlsEl = document.getElementById("controls");

    const gateTokenEl = document.getElementById("gateToken");
    const gateMsgEl = document.getElementById("gateMsg");
    const proceedBtn = document.getElementById("proceedBtn");

    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    const saveBtn = document.getElementById("saveBtn");
    const discardBtn = document.getElementById("discardBtn");
    const reloadBtn = document.getElementById("reloadBtn");

    function setStatus(msg){ statusEl.textContent = msg; }
    function pad2(n){ return String(n).padStart(2,"0"); }
    function toISODate(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
    function addDays(date, days){ const d = new Date(date); d.setDate(d.getDate()+days); return d; }
    function weekdayLabel(d){ return d.toLocaleDateString("en-GB",{weekday:"short"}); }
    function displayDate(d){ return `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${String(d.getFullYear()).slice(-2)}`; }
    function key(dateISO, route){ return `${dateISO}||${route}`; }
    function normaliseHeader(h){ return String(h||"").trim().toLowerCase(); }
    function isISODate(s){ return /^\d{4}-\d{2}-\d{2}$/.test(String(s||"").trim()); }
    function isWeekend(wd){ return wd === 0 || wd === 6; }

    function updateButtons(){
      const n = pending.size;
      saveBtn.disabled = (n === 0);
      discardBtn.disabled = (n === 0);
      saveBtn.textContent = (n === 0) ? "Save changes" : `Save changes (${n})`;
    }

    function truthy(v){
      const s = String(v||"").trim().toLowerCase();
      return !!(s && s !== "0" && s !== "no" && s !== "false" && s !== "n");
    }

    function weekdayIndexFromName(name){
      const n = String(name||"").trim().toLowerCase();
      const map = {
        "sun":0,"sunday":0,
        "mon":1,"monday":1,
        "tue":2,"tues":2,"tuesday":2,
        "wed":3,"wednesday":3,
        "thu":4,"thur":4,"thurs":4,"thursday":4,
        "fri":5,"friday":5,
        "sat":6,"saturday":6
      };
      return (n in map) ? map[n] : null;
    }

    function parseDeliveryDaysString(s){
      const out = new Set();
      const raw = String(s||"").trim();
      if (!raw) return out;
      const parts = raw.split(/[^A-Za-z]+/).filter(Boolean);
      for (const p of parts){
        const idx = weekdayIndexFromName(p);
        if (idx !== null) out.add(idx);
      }
      return out;
    }

    function parseCSV(text){
      const rows = [];
      let cur = [];
      let val = "";
      let inQuotes = false;

      for (let i=0;i<text.length;i++){
        const ch = text[i];
        const next = text[i+1];

        if (ch === '"' && inQuotes && next === '"'){ val+='"'; i++; continue; }
        if (ch === '"'){ inQuotes = !inQuotes; continue; }
        if (ch === "," && !inQuotes){ cur.push(val); val=""; continue; }

        if ((ch === "\n" || ch === "\r") && !inQuotes){
          if (val.length || cur.length){
            cur.push(val);
            rows.push(cur.map(c => c.trim()));
          }
          val=""; cur=[];
          if (ch === "\r" && next === "\n") i++;
          continue;
        }

        val += ch;
      }

      if (val.length || cur.length){
        cur.push(val);
        rows.push(cur.map(c => c.trim()));
      }

      return rows.filter(r => r.some(c => c !== ""));
    }

    function routeRunsOn(route, weekdayIndex){
      const days = schedule.get(route);
      return days ? days.has(weekdayIndex) : false;
    }

    function getEffectiveStatus(dateISO, route){
      const k = key(dateISO, route);
      if (pending.has(k)) return pending.get(k).status;
      if (overrides.has(k)) return overrides.get(k);
      return STATUS.AVAILABLE;
    }

    function applyCellStyle(td, dateISO, route){
      td.classList.remove("inactive","runAvailable","fullWeight","fullDrops","pendingOutline");

      const col = dateCols.find(c => c.iso === dateISO);
      const runs = col ? routeRunsOn(route, col.weekday) : false;

      if (!runs){
        td.classList.add("inactive");
        td.textContent = "";
        return;
      }

      const st = getEffectiveStatus(dateISO, route);
      if (st === STATUS.FULL_WEIGHT) td.classList.add("fullWeight");
      else if (st === STATUS.FULL_DROPS) td.classList.add("fullDrops");
      else td.classList.add("runAvailable");

      if (pending.has(key(dateISO, route))) td.classList.add("pendingOutline");
    }

    function setSelectValueInCell(td, value){
      const sel = td.querySelector("select");
      if (sel) sel.value = value;
    }

    function normaliseDistrictToken(token){
      const t = String(token || "").trim().toUpperCase();
      const m = t.match(/^([A-Z]{1,2})\s*0*(\d{1,2})([A-Z]?)$/);
      if (!m) return null;
      const area = m[1];
      const num = parseInt(m[2], 10);
      const suffix = m[3] || "";
      if (!Number.isFinite(num)) return null;
      return { area, num, suffix, raw: `${area}${num}${suffix}` };
    }

    function extractDistrictsFromPrefixCell(cell){
      const text = String(cell || "").toUpperCase();
      const matches = text.match(/[A-Z]{1,2}\s*0*\d{1,2}[A-Z]?/g) || [];
      const out = [];
      for (const m of matches){
        const d = normaliseDistrictToken(m.replace(/\s+/g,""));
        if (d) out.push(d);
      }
      return out;
    }

    function groupDistrictsToRanges(districts){
      const byAreaNums = new Map();
      const suffixTokens = new Map();

      for (const d of districts){
        if (!d) continue;
        if (d.suffix){
          if (!suffixTokens.has(d.area)) suffixTokens.set(d.area, new Set());
          suffixTokens.get(d.area).add(d.raw);
          continue;
        }
        if (!byAreaNums.has(d.area)) byAreaNums.set(d.area, new Set());
        byAreaNums.get(d.area).add(d.num);
      }

      const parts = [];
      const areas = Array.from(new Set([...byAreaNums.keys(), ...suffixTokens.keys()]))
        .sort((a,b)=>a.localeCompare(b,"en-GB"));

      for (const area of areas){
        const numsSet = byAreaNums.get(area) || new Set();
        const nums = Array.from(numsSet).sort((a,b)=>a-b);

        if (nums.length){
          let start = nums[0], prev = nums[0];
          for (let i=1;i<nums.length;i++){
            const n = nums[i];
            if (n === prev + 1){ prev = n; continue; }
            parts.push(start === prev ? `${area}${start}` : `${area}${start}–${area}${prev}`);
            start = prev = n;
          }
          parts.push(start === prev ? `${area}${start}` : `${area}${start}–${area}${prev}`);
        }

        const sufSet = suffixTokens.get(area);
        if (sufSet && sufSet.size){
          const suf = Array.from(sufSet).sort((a,b)=>a.localeCompare(b,"en-GB",{numeric:true}));
          for (const t of suf) parts.push(t);
        }
      }

      const cleaned = parts.map(p => p.replace(/^([A-Z]{1,2}\d+)–\1([A-Z]{1,2})(\d+)$/, "$1–$2$3"));
      return cleaned.join("; ");
    }

    async function validateToken(token){
      const today = new Date();
      today.setHours(0,0,0,0);
      const iso = toISODate(today);

      const payload = JSON.stringify({
        action: "batch",
        token,
        changes: [{ date: iso, route: "__TOKEN_CHECK__", status: STATUS.AVAILABLE }]
      });

      const res = await fetch(CONFIG.API_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: payload
      });

      const data = await res.json().catch(()=>null);
      return !!(data && data.ok);
    }

    async function loadBankHolidays(){
      bankHolidays.clear();
      const res = await fetch(CONFIG.BANK_HOLIDAYS_CSV_URL, { cache:"no-store" });
      if (!res.ok) return;

      const text = await res.text();
      const rows = parseCSV(text);
      if (!rows.length) return;

      let startRow = 0;
      let dateIdx = 0;

      const maybeHeaders = rows[0].map(normaliseHeader);
      const idx = maybeHeaders.findIndex(h => h === "date" || h === "bankholiday" || h === "bank holiday" || h === "bank_holiday");
      if (idx !== -1){ startRow = 1; dateIdx = idx; }

      for (let r=startRow; r<rows.length; r++){
        const d = String(rows[r][dateIdx] || "").trim();
        if (isISODate(d)) bankHolidays.add(d);
      }
    }

    function buildDateCols(){
      const start = new Date();
      start.setHours(0,0,0,0);

      dateCols = [];
      let i = 0;

      while (dateCols.length < CONFIG.DAYS_AHEAD && i < 730){
        const d = addDays(start, i);
        const iso = toISODate(d);
        const wd = d.getDay();

        if (!isWeekend(wd) && !bankHolidays.has(iso)){
          dateCols.push({ date:d, iso, weekday:wd });
        }
        i++;
      }
    }

    async function loadScheduleFromCSV(){
      const res = await fetch(CONFIG.ROUTES_CSV_URL, { cache:"no-store" });
      if (!res.ok) throw new Error(`Failed to load routes.csv (${res.status})`);

      const text = await res.text();
      const rows = parseCSV(text);
      if (rows.length < 2) throw new Error("routes.csv has no data rows");

      const headers = rows[0].map(normaliseHeader);

      const routeIdx = headers.findIndex(h =>
        h === "route" || h === "routename" || h === "route name" || h === "routecode" || h === "route_code"
      );
      if (routeIdx === -1) throw new Error("routes.csv must include a 'Route' column");

      const prefixIdx = headers.findIndex(h => h === "prefix");
      if (prefixIdx === -1) throw new Error("routes.csv must include a 'prefix' column (postcode prefix/district).");

      const dayCols = new Map();
      headers.forEach((h,i)=>{
        const idx = weekdayIndexFromName(h);
        if (idx !== null) dayCols.set(idx, i);
      });

      const deliveryDaysIdx = headers.findIndex(h =>
        h === "deliverydays" || h === "delivery days" || h === "days" || h === "run days" || h === "rundays"
      );

      schedule.clear();
      routePostcodeGroups.clear();

      const routeDistricts = new Map();

      for (let r=1; r<rows.length; r++){
        const row = rows[r];

        const route = String(row[routeIdx] || "").trim();
        if (!route) continue;

        if (route.toUpperCase().startsWith("3PLCO")) continue;
        if (route.length <= 5) continue;

        let days = new Set();
        if (dayCols.size >= 5){
          for (const [w,col] of dayCols.entries()){
            if (truthy(row[col])) days.add(w);
          }
        } else if (deliveryDaysIdx !== -1){
          days = parseDeliveryDaysString(row[deliveryDaysIdx]);
        } else {
          continue;
        }

        if (days.size) schedule.set(route, days);

        const prefixCell = row[prefixIdx];
        if (!routeDistricts.has(route)) routeDistricts.set(route, []);
        routeDistricts.get(route).push(...extractDistrictsFromPrefixCell(prefixCell));
      }

      if (schedule.size === 0) throw new Error("No route schedules inferred from routes.csv (after exclusions).");

      for (const [route, districts] of routeDistricts.entries()){
        const grouped = groupDistrictsToRanges(districts);
        routePostcodeGroups.set(route, grouped);
      }
    }

    async function loadOverrides(fromISO, toISO){
      overrides.clear();
      const url = `${CONFIG.API_URL}?action=get&from=${encodeURIComponent(fromISO)}&to=${encodeURIComponent(toISO)}`;
      const res = await fetch(url, { cache:"no-store" });
      const data = await res.json().catch(()=>null);
      if (!data || !data.ok) throw new Error(`API failed: ${(data && data.error) ? data.error : "Unknown error"}`);

      for (const row of (data.rows || [])){
        const date = String(row.date || "").trim();
        const route = String(row.route || "").trim();
        const status = String(row.status || "").trim();
        if (!date || !route || !status) continue;
        overrides.set(key(date, route), status);
      }
    }

    function buildGrid(){
      gridEl.innerHTML = "";
      cellByKey.clear();

      const routes = Array.from(schedule.keys())
        .sort((a,b)=>a.localeCompare(b,"en-GB",{numeric:true,sensitivity:"base"}));

      const thead = document.createElement("thead");
      const hr = document.createElement("tr");

      const thRoute = document.createElement("th");
      thRoute.textContent = "Route";
      thRoute.className = "routeHead routeCell";
      hr.appendChild(thRoute);

      for (const c of dateCols){
        const th = document.createElement("th");
        th.innerHTML = `${weekdayLabel(c.date)}<br>${displayDate(c.date)}`;
        hr.appendChild(th);
      }

      thead.appendChild(hr);
      gridEl.appendChild(thead);

      const tbody = document.createElement("tbody");

      for (const route of routes){
        const tr = document.createElement("tr");

        const tdRoute = document.createElement("td");
        tdRoute.className = "routeCell";

        const wrap = document.createElement("span");
        wrap.className = "routeName";
        wrap.textContent = route;

        const tooltip = document.createElement("div");
        tooltip.className = "routeTooltip";

        const title = document.createElement("div");
        title.className = "routeTooltipTitle";
        title.textContent = "Postcode groups";

        const body = document.createElement("div");
        body.className = "routeTooltipBody";
        const groups = routePostcodeGroups.get(route) || "";
        body.textContent = groups ? groups : "No postcode groups found for this route.";

        tooltip.appendChild(title);
        tooltip.appendChild(body);
        wrap.appendChild(tooltip);
        tdRoute.appendChild(wrap);

        tr.appendChild(tdRoute);

        for (const c of dateCols){
          const td = document.createElement("td");
          const runs = routeRunsOn(route, c.weekday);

          if (!runs){
            td.className = "inactive";
            td.textContent = "";
          } else {
            const sel = document.createElement("select");
            sel.innerHTML = `
              <option value="${STATUS.AVAILABLE}">${STATUS.AVAILABLE}</option>
              <option value="${STATUS.FULL_WEIGHT}">${STATUS.FULL_WEIGHT}</option>
              <option value="${STATUS.FULL_DROPS}">${STATUS.FULL_DROPS}</option>
            `;

            const k = key(c.iso, route);
            sel.value = overrides.get(k) || STATUS.AVAILABLE;

            sel.addEventListener("change", () => {
              pending.set(k, { date: c.iso, route, status: sel.value });
              updateButtons();
              applyCellStyle(td, c.iso, route);
              setStatus(`Pending: ${route} on ${c.iso} -> ${sel.value}`);
            });

            td.appendChild(sel);
            applyCellStyle(td, c.iso, route);
            cellByKey.set(k, td);
          }

          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      }

      gridEl.appendChild(tbody);
    }

    function discardPending(){
      pending.clear();
      updateButtons();

      for (const [k, td] of cellByKey.entries()){
        const [dateISO, route] = k.split("||");
        const st = overrides.get(k) || STATUS.AVAILABLE;
        setSelectValueInCell(td, st);
        applyCellStyle(td, dateISO, route);
      }

      setStatus("Pending changes discarded.");
    }

    async function savePending(){
      if (pending.size === 0) return;

      const changes = Array.from(pending.values());
      setStatus(`Saving ${changes.length} change(s)...`);

      const payload = JSON.stringify({
        action: "batch",
        token: sessionToken,
        changes
      });

      const res = await fetch(CONFIG.API_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: payload
      });

      const data = await res.json().catch(()=>null);
      if (!data || !data.ok){
        setStatus(`Save failed: ${(data && data.error) ? data.error : "Unknown error"}`);
        return;
      }

      pending.clear();
      updateButtons();

      await loadOverrides(dateCols[0].iso, dateCols[dateCols.length-1].iso);

      for (const [k, td] of cellByKey.entries()){
        const [dateISO, route] = k.split("||");
        const st = overrides.get(k) || STATUS.AVAILABLE;
        setSelectValueInCell(td, st);
        applyCellStyle(td, dateISO, route);
      }

      setStatus("Saved.");
    }

    async function fullReload(){
      try{
        setStatus("Loading...");
        pending.clear();
        updateButtons();

        await loadBankHolidays();
        buildDateCols();

        await loadScheduleFromCSV();
        await loadOverrides(dateCols[0].iso, dateCols[dateCols.length-1].iso);

        buildGrid();
        setStatus("Loaded.");
      }catch(err){
        setStatus(`Error: ${String(err.message || err)}`);
        console.error(err);
      }
    }

    async function proceed(){
      const token = (gateTokenEl.value || "").trim();
      if (!token){
        gateMsgEl.textContent = "Please enter the admin token.";
        return;
      }

      proceedBtn.disabled = true;
      gateMsgEl.textContent = "Checking token...";
      setStatus("Checking token...");

      const ok = await validateToken(token);

      if (!ok){
        proceedBtn.disabled = false;
        gateMsgEl.textContent = "Token incorrect. Please try again.";
        setStatus("Token incorrect.");
        gateTokenEl.focus();
        return;
      }

      sessionToken = token;

      gateEl.classList.add("hidden");
      appEl.classList.remove("hidden");
      controlsEl.classList.remove("hidden");

      await fullReload();
    }

    proceedBtn.addEventListener("click", proceed);
    gateTokenEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") proceed();
    });

    reloadBtn.addEventListener("click", fullReload);
    discardBtn.addEventListener("click", discardPending);
    saveBtn.addEventListener("click", savePending);

    window.addEventListener("beforeunload", (e) => {
      if (pending.size > 0){
        e.preventDefault();
        e.returnValue = "";
      }
    });
  </script>
</body>
</html>
