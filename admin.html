<!doctype html>
<html lang="en-GB">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Transport Team Admin</title>
  <style>
    :root{
      --border:#cfcfcf;
      --header:#efefef;
      --routecol:#e6e6e6;
      --inactive:#f7f7f7;

      --green:#00b050;   /* Available run */
      --red:#ff0000;     /* Full - On Weight */
      --orange:#ffc000;  /* Full - On Drops */

      --text:#111;
    }

    body{
      font-family: Arial, sans-serif;
      margin: 18px;
      color: var(--text);
      background: #fff;
    }

    /* ---------- TOKEN GATE ---------- */
    .gateWrap{
      max-width: 520px;
      margin: 0 auto;
      border: 1px solid #ddd;
      border-radius: 14px;
      padding: 16px 16px 14px;
      background: #fff;
    }
    .gateRow{
      display:flex;
      gap:10px;
      align-items:center;
      margin-top:12px;
      flex-wrap:wrap;
      justify-content:center;
    }
    .gateRow input{
      flex: 1;
      min-width: 240px;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid #bbb;
      font-size: 14px;
    }

    /* ---------- TOP LAYOUT ---------- */
    .top{
      max-width: 1400px;
      margin: 0 auto 14px;
      text-align: center;
    }
    h1{
      margin: 0 0 10px;
      font-size: 24px;       /* slightly larger */
      font-weight: 800;
      letter-spacing: .2px;
    }

    .btn{
      padding: 10px 12px;
      cursor: pointer;
      border: 1px solid #bbb;
      background: #fff;
      border-radius: 10px;
      font-weight: 700;
    }
    .btn:disabled{opacity:.55;cursor:not-allowed}

    .bar{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;   /* centred buttons */
      margin: 0 0 12px;         /* space under buttons */
    }

    .status{
      margin: 0 auto 14px;      /* moved under header/buttons area */
      font-size: 13px;
      color: #333;
      min-height: 18px;
    }

    /* ---------- LEGEND ---------- */
    .legend{
      display:flex;
      gap:12px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:center;
      margin: 18px 0 14px;      /* more space above/below */
      font-size: 13px;
    }
    .chip{display:inline-flex;align-items:center;gap:6px}
    .dot{width:12px;height:12px;border-radius:3px;display:inline-block;border:1px solid #999}

    /* ---------- TABLE ---------- */
    .wrap{
      max-width: 1400px;
      margin: 0 auto;
      overflow-x: auto;
      border: 1px solid #ccc;
      border-radius: 12px;
    }

    table{
      border-collapse: collapse;
      width: 100%;
      table-layout: fixed;      /* forces consistent column widths */
      min-width: 1100px;
    }

    th, td{
      border: 1px solid var(--border);
      padding: 10px 8px;        /* taller rows */
      text-align: center;
      vertical-align: middle;
      height: 48px;             /* a touch larger */
      word-break: break-word;   /* wrap long text */
      white-space: normal;      /* allow wrap */
    }

    th{
      background: var(--header);
      font-weight: 800;
      font-size: 13px;
      line-height: 1.2;
    }

    /* Route column fixed width; all date columns equal width */
    th.routeHead, td.routeCell{
      width: 260px;
    }
    /* Each date column roughly equal; table-layout:fixed handles equal widths */
    th:not(.routeHead), td:not(.routeCell){
      width: 120px;
    }

    .routeCell{
      background: var(--routecol);
      font-weight: 800;
      text-align: left;
      position: sticky;
      left: 0;
      z-index: 2;
    }
    th.routeHead{
      position: sticky;
      left: 0;
      z-index: 3;
    }

    .inactive{background: var(--inactive)}
    .runAvailable{background: var(--green)}
    .fullWeight{background: var(--red); color:#fff}
    .fullDrops{background: var(--orange)}
    .pendingOutline{outline:3px solid #00000022;outline-offset:-3px}

    select{
      width: 100%;
      max-width: 100%;
      border: 0;
      background: transparent;
      font-weight: 800;
      cursor: pointer;
      appearance: none;
      text-align: center;
      text-align-last: center;
      white-space: normal;      /* allow wrap inside select */
      word-break: break-word;
      line-height: 1.2;
    }

    /* Optional: make selects look consistent on some browsers */
    select:focus{outline: 2px solid #00000015; outline-offset: 2px;}

    /* ---------- HIDE/SHOW ---------- */
    .hidden{display:none !important;}

    /* ---------- SMALL SCREENS ---------- */
    @media (max-width: 520px){
      h1{font-size: 20px}
      .gateRow input{min-width: 200px}
      th.routeHead, td.routeCell{width: 220px}
      th:not(.routeHead), td:not(.routeCell){width: 110px}
    }
  </style>
</head>
<body>

  <div class="top">
    <h1>Transport Team Admin</h1>

    <!-- Loading/status message moved here (under header) -->
    <div class="status" id="status">Ready.</div>

    <!-- Buttons centred -->
    <div class="bar hidden" id="controls">
      <button class="btn" id="reloadBtn">Reload</button>
      <button class="btn" id="discardBtn" disabled>Discard pending</button>
      <button class="btn" id="saveBtn" disabled>Save changes</button>
    </div>
  </div>

  <!-- TOKEN GATE (only thing visible until Proceed) -->
  <div id="gate" class="gateWrap">
    <div style="font-size:13px;color:#444;line-height:1.4;text-align:center">
      Enter the admin token to access the transport status editor.
    </div>

    <div class="gateRow">
      <input id="gateToken" type="password" placeholder="Admin token" autocomplete="off" />
      <button id="proceedBtn" class="btn">Proceed</button>
    </div>

    <div id="gateMsg" style="margin-top:10px;font-size:13px;color:#333;line-height:1.35;text-align:center">
      Token is required each time the page loads.
    </div>
  </div>

  <!-- APP UI (hidden until token validated) -->
  <div id="app" class="hidden">

    <!-- Legend moved under buttons with spacing -->
    <div class="legend">
      <span class="chip"><span class="dot" style="background:var(--green)"></span> Available (scheduled run)</span>
      <span class="chip"><span class="dot" style="background:var(--red)"></span> Full - On Weight</span>
      <span class="chip"><span class="dot" style="background:var(--orange)"></span> Full - On Drops</span>
      <span class="chip"><span class="dot" style="background:var(--inactive)"></span> Not a run day</span>
    </div>

    <div class="wrap">
      <table id="grid"></table>
    </div>

  </div>

  <script>
    /******************************************************************
     * CONFIG
     ******************************************************************/
    const CONFIG = {
      API_URL: "https://script.google.com/macros/s/AKfycbz4A-9fYDa5hbzvP_LxCka1Mwxfg8MYQj4lwKx1oPFRWBC2PX71z64neOFmpBgjDD8oAw/exec",
      ROUTES_CSV_URL: "./routes.csv",
      BANK_HOLIDAYS_CSV_URL: "./bank_holidays.csv",
      DAYS_AHEAD: 10 // working-day columns (weekends + BH skipped)
    };

    const STATUS = {
      AVAILABLE: "Available",
      FULL_WEIGHT: "Full - On Weight",
      FULL_DROPS: "Full - On Drops"
    };

    /******************************************************************
     * State
     ******************************************************************/
    let sessionToken = "";          // in-memory only
    const pending = new Map();      // key(date||route) -> {date, route, status}
    const overrides = new Map();    // key(date||route) -> status
    const schedule = new Map();     // route -> Set(weekdayIndex)
    const bankHolidays = new Set(); // Set(YYYY-MM-DD)
    let dateCols = [];              // [{date, iso, weekday}]
    const cellByKey = new Map();    // key(date||route) -> td

    /******************************************************************
     * Elements
     ******************************************************************/
    const gateEl = document.getElementById("gate");
    const appEl = document.getElementById("app");
    const controlsEl = document.getElementById("controls");

    const gateTokenEl = document.getElementById("gateToken");
    const gateMsgEl = document.getElementById("gateMsg");
    const proceedBtn = document.getElementById("proceedBtn");

    const gridEl = document.getElementById("grid");
    const statusEl = document.getElementById("status");
    const saveBtn = document.getElementById("saveBtn");
    const discardBtn = document.getElementById("discardBtn");
    const reloadBtn = document.getElementById("reloadBtn");

    /******************************************************************
     * Utils
     ******************************************************************/
    function setStatus(msg){ statusEl.textContent = msg; }
    function pad2(n){ return String(n).padStart(2,"0"); }
    function toISODate(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
    function addDays(date, days){ const d = new Date(date); d.setDate(d.getDate()+days); return d; }
    function weekdayLabel(d){ return d.toLocaleDateString("en-GB",{weekday:"short"}); }
    function displayDate(d){ return `${pad2(d.getDate())}/${pad2(d.getMonth()+1)}/${String(d.getFullYear()).slice(-2)}`; }
    function key(dateISO, route){ return `${dateISO}||${route}`; }
    function normaliseHeader(h){ return String(h||"").trim().toLowerCase(); }
    function isISODate(s){ return /^\d{4}-\d{2}-\d{2}$/.test(String(s||"").trim()); }
    function isWeekend(wd){ return wd === 0 || wd === 6; }

    function updateButtons(){
      const n = pending.size;
      saveBtn.disabled = (n === 0);
      discardBtn.disabled = (n === 0);
      saveBtn.textContent = (n === 0) ? "Save changes" : `Save changes (${n})`;
    }

    function truthy(v){
      const s = String(v||"").trim().toLowerCase();
      return !!(s && s !== "0" && s !== "no" && s !== "false" && s !== "n");
    }

    function weekdayIndexFromName(name){
      const n = String(name||"").trim().toLowerCase();
      const map = {
        "sun":0,"sunday":0,
        "mon":1,"monday":1,
        "tue":2,"tues":2,"tuesday":2,
        "wed":3,"wednesday":3,
        "thu":4,"thur":4,"thurs":4,"thursday":4,
        "fri":5,"friday":5,
        "sat":6,"saturday":6
      };
      return (n in map) ? map[n] : null;
    }

    function parseDeliveryDaysString(s){
      const out = new Set();
      const raw = String(s||"").trim();
      if (!raw) return out;
      const parts = raw.split(/[^A-Za-z]+/).filter(Boolean);
      for (const p of parts){
        const idx = weekdayIndexFromName(p);
        if (idx !== null) out.add(idx);
      }
      return out;
    }

    function parseCSV(text){
      const rows = [];
      let cur = [];
      let val = "";
      let inQuotes = false;

      for (let i=0;i<text.length;i++){
        const ch = text[i];
        const next = text[i+1];

        if (ch === '"' && inQuotes && next === '"'){ val+='"'; i++; continue; }
        if (ch === '"'){ inQuotes = !inQuotes; continue; }
        if (ch === "," && !inQuotes){ cur.push(val); val=""; continue; }

        if ((ch === "\n" || ch === "\r") && !inQuotes){
          if (val.length || cur.length){
            cur.push(val);
            rows.push(cur.map(c => c.trim()));
          }
          val=""; cur=[];
          if (ch === "\r" && next === "\n") i++;
          continue;
        }

        val += ch;
      }

      if (val.length || cur.length){
        cur.push(val);
        rows.push(cur.map(c => c.trim()));
      }

      return rows.filter(r => r.some(c => c !== ""));
    }

    function routeRunsOn(route, weekdayIndex){
      const days = schedule.get(route);
      return days ? days.has(weekdayIndex) : false;
    }

    function getEffectiveStatus(dateISO, route){
      const k = key(dateISO, route);
      if (pending.has(k)) return pending.get(k).status;
      if (overrides.has(k)) return overrides.get(k);
      return STATUS.AVAILABLE;
    }

    function applyCellStyle(td, dateISO, route){
      td.classList.remove("inactive","runAvailable","fullWeight","fullDrops","pendingOutline");

      const col = dateCols.find(c => c.iso === dateISO);
      const runs = col ? routeRunsOn(route, col.weekday) : false;

      if (!runs){
        td.classList.add("inactive");
        td.textContent = "";
        return;
      }

      const st = getEffectiveStatus(dateISO, route);
      if (st === STATUS.FULL_WEIGHT) td.classList.add("fullWeight");
      else if (st === STATUS.FULL_DROPS) td.classList.add("fullDrops");
      else td.classList.add("runAvailable");

      if (pending.has(key(dateISO, route))) td.classList.add("pendingOutline");
    }

    function setSelectValueInCell(td, value){
      const sel = td.querySelector("select");
      if (sel) sel.value = value;
    }

    /******************************************************************
     * Token “login” validation (no-op write: Available on dummy route)
     ******************************************************************/
    async function validateToken(token){
      const today = new Date();
      today.setHours(0,0,0,0);
      const iso = toISODate(today);

      const payload = JSON.stringify({
        action: "batch",
        token,
        changes: [{ date: iso, route: "__TOKEN_CHECK__", status: STATUS.AVAILABLE }]
      });

      const res = await fetch(CONFIG.API_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: payload
      });

      const data = await res.json().catch(()=>null);
      return !!(data && data.ok);
    }

    /******************************************************************
     * Data loading
     ******************************************************************/
    async function loadBankHolidays(){
      bankHolidays.clear();
      const res = await fetch(CONFIG.BANK_HOLIDAYS_CSV_URL, { cache:"no-store" });
      if (!res.ok) return;

      const text = await res.text();
      const rows = parseCSV(text);
      if (rows.length === 0) return;

      let startRow = 0;
      let dateIdx = 0;

      const maybeHeaders = rows[0].map(normaliseHeader);
      const idx = maybeHeaders.findIndex(h => h === "date" || h === "bankholiday" || h === "bank holiday" || h === "bank_holiday");
      if (idx !== -1){ startRow = 1; dateIdx = idx; }

      for (let r=startRow; r<rows.length; r++){
        const d = String(rows[r][dateIdx] || "").trim();
        if (isISODate(d)) bankHolidays.add(d);
      }
    }

    function buildDateCols(){
      const start = new Date();
      start.setHours(0,0,0,0);

      dateCols = [];
      let i = 0;

      while (dateCols.length < CONFIG.DAYS_AHEAD && i < 730){
        const d = addDays(start, i);
        const iso = toISODate(d);
        const wd = d.getDay();

        if (!isWeekend(wd) && !bankHolidays.has(iso)){
          dateCols.push({ date:d, iso, weekday:wd });
        }
        i++;
      }
    }

    async function loadScheduleFromCSV(){
      const res = await fetch(CONFIG.ROUTES_CSV_URL, { cache:"no-store" });
      if (!res.ok) throw new Error(`Failed to load routes.csv (${res.status})`);

      const text = await res.text();
      const rows = parseCSV(text);
      if (rows.length < 2) throw new Error("routes.csv has no data rows");

      const headers = rows[0].map(normaliseHeader);

      const routeIdx = headers.findIndex(h =>
        h === "route" || h === "routename" || h === "route name" || h === "routecode" || h === "route_code"
      );
      if (routeIdx === -1) throw new Error("routes.csv must include a 'Route' column");

      const dayCols = new Map();
      headers.forEach((h,i)=>{
        const idx = weekdayIndexFromName(h);
        if (idx !== null) dayCols.set(idx, i);
      });

      const deliveryDaysIdx = headers.findIndex(h =>
        h === "deliverydays" || h === "delivery days" || h === "days" || h === "run days" || h === "rundays"
      );

      schedule.clear();

      for (let r=1; r<rows.length; r++){
        const row = rows[r];
        const route = String(row[routeIdx] || "").trim();
        if (!route) continue;

        // Exclusions you requested:
        if (route.toUpperCase().startsWith("3PLCO")) continue;
        if (route.length <= 5) continue;

        let days = new Set();
        if (dayCols.size >= 5){
          for (const [w,col] of dayCols.entries()){
            if (truthy(row[col])) days.add(w);
          }
        } else if (deliveryDaysIdx !== -1){
          days = parseDeliveryDaysString(row[deliveryDaysIdx]);
        } else {
          continue;
        }

        if (days.size) schedule.set(route, days);
      }

      if (schedule.size === 0) throw new Error("No route schedules inferred from routes.csv (after exclusions).");
    }

    async function loadOverrides(fromISO, toISO){
      overrides.clear();
      const url = `${CONFIG.API_URL}?action=get&from=${encodeURIComponent(fromISO)}&to=${encodeURIComponent(toISO)}`;
      const res = await fetch(url, { cache:"no-store" });
      const data = await res.json().catch(()=>null);
      if (!data || !data.ok) throw new Error(`API failed: ${(data && data.error) ? data.error : "Unknown error"}`);

      for (const row of (data.rows || [])){
        const date = String(row.date || "").trim();
        const route = String(row.route || "").trim();
        const status = String(row.status || "").trim();
        if (!date || !route || !status) continue;
        overrides.set(key(date, route), status);
      }
    }

    /******************************************************************
     * Grid
     ******************************************************************/
    function buildGrid(){
      gridEl.innerHTML = "";
      cellByKey.clear();

      const routes = Array.from(schedule.keys())
        .sort((a,b)=>a.localeCompare(b,"en-GB",{numeric:true,sensitivity:"base"}));

      const thead = document.createElement("thead");
      const hr = document.createElement("tr");

      const thRoute = document.createElement("th");
      thRoute.textContent = "Route";
      thRoute.className = "routeHead routeCell";
      hr.appendChild(thRoute);

      for (const c of dateCols){
        const th = document.createElement("th");
        th.innerHTML = `${weekdayLabel(c.date)}<br>${displayDate(c.date)}`;
        hr.appendChild(th);
      }

      thead.appendChild(hr);
      gridEl.appendChild(thead);

      const tbody = document.createElement("tbody");

      for (const route of routes){
        const tr = document.createElement("tr");

        const tdRoute = document.createElement("td");
        tdRoute.textContent = route;
        tdRoute.className = "routeCell";
        tr.appendChild(tdRoute);

        for (const c of dateCols){
          const td = document.createElement("td");
          const runs = routeRunsOn(route, c.weekday);

          if (!runs){
            td.className = "inactive";
            td.textContent = "";
          } else {
            const sel = document.createElement("select");
            sel.innerHTML = `
              <option value="${STATUS.AVAILABLE}">${STATUS.AVAILABLE}</option>
              <option value="${STATUS.FULL_WEIGHT}">${STATUS.FULL_WEIGHT}</option>
              <option value="${STATUS.FULL_DROPS}">${STATUS.FULL_DROPS}</option>
            `;

            const k = key(c.iso, route);
            sel.value = overrides.get(k) || STATUS.AVAILABLE;

            sel.addEventListener("change", () => {
              pending.set(k, { date: c.iso, route, status: sel.value });
              updateButtons();
              applyCellStyle(td, c.iso, route);
              setStatus(`Pending: ${route} on ${c.iso} -> ${sel.value}`);
            });

            td.appendChild(sel);
            applyCellStyle(td, c.iso, route);
            cellByKey.set(k, td);
          }

          tr.appendChild(td);
        }

        tbody.appendChild(tr);
      }

      gridEl.appendChild(tbody);
    }

    function discardPending(){
      pending.clear();
      updateButtons();

      for (const [k, td] of cellByKey.entries()){
        const [dateISO, route] = k.split("||");
        const st = overrides.get(k) || STATUS.AVAILABLE;
        setSelectValueInCell(td, st);
        applyCellStyle(td, dateISO, route);
      }

      setStatus("Pending changes discarded.");
    }

    async function savePending(){
      if (pending.size === 0) return;

      const changes = Array.from(pending.values());
      setStatus(`Saving ${changes.length} change(s)...`);

      const payload = JSON.stringify({
        action: "batch",
        token: sessionToken,
        changes
      });

      const res = await fetch(CONFIG.API_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: payload
      });

      const data = await res.json().catch(()=>null);
      if (!data || !data.ok){
        setStatus(`Save failed: ${(data && data.error) ? data.error : "Unknown error"}`);
        return;
      }

      pending.clear();
      updateButtons();

      await loadOverrides(dateCols[0].iso, dateCols[dateCols.length-1].iso);

      for (const [k, td] of cellByKey.entries()){
        const [dateISO, route] = k.split("||");
        const st = overrides.get(k) || STATUS.AVAILABLE;
        setSelectValueInCell(td, st);
        applyCellStyle(td, dateISO, route);
      }

      setStatus("Saved.");
    }

    async function fullReload(){
      try{
        setStatus("Loading...");
        pending.clear();
        updateButtons();

        await loadBankHolidays();
        buildDateCols();

        await loadScheduleFromCSV();
        await loadOverrides(dateCols[0].iso, dateCols[dateCols.length-1].iso);

        buildGrid();
        setStatus("Loaded.");
      }catch(err){
        setStatus(`Error: ${String(err.message || err)}`);
        console.error(err);
      }
    }

    /******************************************************************
     * Gate behaviour
     ******************************************************************/
    async function proceed(){
      const token = (gateTokenEl.value || "").trim();
      if (!token){
        gateMsgEl.textContent = "Please enter the admin token.";
        return;
      }

      proceedBtn.disabled = true;
      gateMsgEl.textContent = "Checking token...";
      setStatus("Checking token...");

      const ok = await validateToken(token);

      if (!ok){
        proceedBtn.disabled = false;
        gateMsgEl.textContent = "Token incorrect. Please try again.";
        setStatus("Token incorrect.");
        gateTokenEl.focus();
        return;
      }

      sessionToken = token;

      // Show app, hide gate
      gateEl.classList.add("hidden");
      appEl.classList.remove("hidden");
      controlsEl.classList.remove("hidden");

      await fullReload();
    }

    proceedBtn.addEventListener("click", proceed);
    gateTokenEl.addEventListener("keydown", (e) => {
      if (e.key === "Enter") proceed();
    });

    reloadBtn.addEventListener("click", fullReload);
    discardBtn.addEventListener("click", discardPending);
    saveBtn.addEventListener("click", savePending);

    window.addEventListener("beforeunload", (e) => {
      if (pending.size > 0){
        e.preventDefault();
        e.returnValue = "";
      }
    });

    // No auto-load; token gate shown by default.
  </script>
</body>
</html>
