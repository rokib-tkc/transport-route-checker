<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Transport Route Checker</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { box-sizing: border-box; font-family: Arial, sans-serif; }

    body { margin: 0; padding: 20px; background: #f5f5f5; color: #222; }

    h1 { margin-top: 0; font-size: 24px; text-align: center; }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      background: #ffffff;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      position: relative;
    }

    /* Top-right link (Routes Status) */
    .top-link {
      position: absolute;
      top: 14px;
      right: 16px;
      font-size: 13px;
      font-weight: 800;
      color: #0078d4;
      text-decoration: underline;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }
    .top-link:hover { color: #005ea3; }

    .search-section {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      margin-bottom: 10px;
    }

    .search-section label { font-weight: bold; }

    .search-input-wrapper {
      flex: 1 1 200px;
      display: flex;
      gap: 8px;
    }

    input[type="text"] {
      flex: 1;
      padding: 8px 10px;
      font-size: 14px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    button {
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 5px;
      border: none;
      cursor: pointer;
      background: #0078d4;
      color: #fff;
      font-weight: 700;
    }
    button:hover { background: #005ea3; }
    button:disabled { background: #9bbbd7; cursor: not-allowed; }

    .results-header { margin-top: 10px; font-size: 14px; font-weight: bold; }

    .no-results {
      margin-top: 10px;
      padding: 10px;
      border-radius: 5px;
      font-size: 13px;
      background: #ffe5e5;
      color: #a00;
    }

    .channel-block {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      background: #fafafa;
      border: 1px solid #e0e0e0;
    }

    .channel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .channel-title { font-size: 16px; font-weight: bold; }

    .channel-rules-trigger {
      font-size: 12px;
      color: #0078d4;
      text-decoration: underline;
      cursor: help;
      white-space: nowrap;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 5px;
      font-size: 13px;
      table-layout: fixed;
      background: #fff;
    }

    th, td {
      padding: 6px 8px;
      border: 1px solid #ddd;
      text-align: left;
      overflow-wrap: break-word;
    }

    th { background: #f0f0f0; font-weight: bold; }

    .lead-time { white-space: nowrap; }

    #channelTooltip {
      position: fixed;
      z-index: 9999;
      max-width: 320px;
      padding: 10px;
      background: #ffffff;
      border: 1px solid #ccc;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      font-size: 12px;
      line-height: 1.4;
      display: none;
    }

    /* ============================================================
       ROUTE STATUS STRIP (View-only) — softened colours
       ============================================================ */
    :root{
      --border:#cfcfcf;
      --header:#f0f0f0;
      --inactive:#f7f7f7;

      /* softened status colours */
      --green:#dff3e6;    /* light mint */
      --red:#f7d6d6;      /* light rose */
      --orange:#fde8c8;   /* light amber */
    }

    .status-strip{
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      overflow: hidden;
      background: #fff;
    }

    .status-strip table{
      margin-top: 0;
      border: 0;
      font-size: 13px;
    }

    .status-strip th,
    .status-strip td{
      border: 1px solid #ddd;
      height: 44px;
      padding: 0;
      text-align: center;
      vertical-align: middle;
      line-height: 1.15;
      word-break: break-word;
    }

    .status-strip thead th{
      background: var(--header);
      font-weight: 700;
      font-size: 13px;
    }

    .status-strip .statusCell{
      font-weight: 700;
      font-size: 12.5px;
    }

    .inactiveCell{
      background: var(--inactive);
      color: #555;
    }

    .availableCell{
      background: var(--green);
      color: #1f6b3a;
    }

    .fullWeightCell{
      background: var(--red);
      color: #8a1f1f;
    }

    .fullDropsCell{
      background: var(--orange);
      color: #8a5a12;
    }

    /* Placeholder message while strip loads */
    .strip-loading{
      margin-top: 10px;
      border: 1px dashed #cfcfcf;
      border-radius: 8px;
      padding: 10px 12px;
      background: #fff;
      font-size: 13px;
      color: #444;
    }

    /* ============================================================
       LOADING OVERLAY (main search)
       ============================================================ */
    .loading-overlay{
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.75);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 99999;
      padding: 20px;
    }
    .loading-panel{
      width: 100%;
      max-width: 360px;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      padding: 16px 18px;
      text-align: center;
    }
    .spinner{
      width: 46px;
      height: 46px;
      border-radius: 50%;
      border: 5px solid #d9d9d9;
      border-top-color: #0078d4;
      margin: 0 auto 12px;
      animation: spin 0.85s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .loading-title{
      font-size: 14px;
      font-weight: 700;
      margin: 0 0 4px;
      color: #111;
    }
    .loading-sub{
      font-size: 12.5px;
      margin: 0;
      color: #444;
      line-height: 1.35;
    }

    /* ============================================================
       ROUTES STATUS OVERLAY (view-only grid)
       ============================================================ */
    .overlay{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.55);
      z-index: 1000000;
      display: none;
      align-items: stretch;
      justify-content: stretch;
      padding: 18px;
    }
    .overlayPanel{
      width: 100%;
      height: 100%;
      background: #ffffff;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
    }
    .overlayHeader{
      padding: 14px 16px;
      background: #f7f7f7;
      border-bottom: 1px solid #e5e5e5;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }
    .overlayTitle{
      font-size: 16px;
      font-weight: 800;
      margin: 0;
    }
    .overlayControls{
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .overlayBtn{
      padding: 8px 14px;
      font-size: 13px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      background: #0078d4;
      color: #fff;
      font-weight: 800;
    }
    .overlayBtn:hover{ background:#005ea3; }
    .overlayBtn:disabled{ background:#9bbbd7; cursor:not-allowed; }

    .overlayClose{
      padding: 8px 12px;
      font-size: 13px;
      border-radius: 6px;
      border: 1px solid #0078d4;
      background: transparent;
      color: #0078d4;
      font-weight: 800;
      cursor: pointer;
      user-select:none;
    }
    .overlayClose:hover{
      background:#0078d4;
      color:#fff; /* requested: white on hover */
    }

    .overlayBody{
      padding: 12px 12px;
      overflow: auto;
      background: #fafafa;
      flex: 1;
    }

    .overlayLoadingRow{
      display:flex;
      gap:10px;
      align-items:center;
      padding: 10px 12px;
      background:#fff;
      border:1px solid #e0e0e0;
      border-radius:10px;
      max-width: 520px;
      margin: 10px auto;
    }
    .overlaySpinner{
      width: 28px;
      height: 28px;
      border-radius: 50%;
      border: 4px solid #d9d9d9;
      border-top-color:#0078d4;
      animation: spin 0.85s linear infinite;
      flex: 0 0 auto;
    }
    .overlayLoadingText{
      font-size: 13px;
      font-weight: 700;
      color:#222;
    }

    /* View-only grid styles (match admin-ish behaviour, but Route Checker colours) */
    .routesGridWrap{
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      background: #fff;
      overflow: visible; /* IMPORTANT: do not clip tooltips */
    }

    table.routesGrid{
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
      background: #fff;
      border: 0;
      font-size: 13px;
    }

    .routesGrid th, .routesGrid td{
      border: 1px solid #ddd;
      padding: 6px 8px;
      text-align: center;
      vertical-align: middle;
      height: 44px;
      line-height: 1.2;
      word-break: break-word;
      overflow-wrap: break-word;
      white-space: normal;
    }
    .routesGrid th{
      background: var(--header);
      font-weight: 800;
    }

    .routesGrid .routeHead{
      width: 260px;
      position: sticky;
      left: 0;
      z-index: 60;
      text-align: left;
      padding: 8px 10px;
    }

    .routesGrid .routeCell{
      width: 260px;
      background: #e6e6e6;
      position: sticky;
      left: 0;
      z-index: 50;
      text-align: left;
      padding: 8px 10px;
      overflow: visible;
    }

    /* Match Route Checker palette */
    .gridInactive{ background: var(--inactive); color:#555; }
    .gridAvailable{ background: var(--green); color:#1f6b3a; font-weight:800; }
    .gridFullWeight{ background: var(--red); color:#8a1f1f; font-weight:800; }
    .gridFullDrops{ background: var(--orange); color:#8a5a12; font-weight:800; }

    /* Tooltip (postcode groups) */
    .routeName{
      position: relative;
      display: inline-block;
      max-width: 100%;
      cursor: help;
      z-index: 1;
    }
    .routeTooltip{
      position: absolute;
      top: calc(100% + 8px);
      z-index: 1000005; /* must beat sticky + overlay layers */
      min-width: 280px;
      max-width: 520px;
      background: #fff;
      border: 1px solid #ccc;
      border-radius: 10px;
      padding: 10px 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.12);
      text-align: left;
      opacity: 0;
      transform: translateY(-4px);
      pointer-events: none;
      transition: opacity .12s ease, transform .12s ease;
      font-size: 12px;
      line-height: 1.4;
      color: #111;
      white-space: normal;
      word-break: break-word;
    }
    .routeName:hover .routeTooltip{
      opacity: 1;
      transform: translateY(0);
    }
    .routeTooltipTitle{
      font-weight: 800;
      margin-bottom: 6px;
      font-size: 12px;
    }
    .routeTooltipBody{
      font-weight: 700;
      color: #333;
    }

    /* ensure hovered row is on top */
    .routesGrid tbody{ position: relative; z-index: 1; }
    .routesGrid tbody tr:hover{ position: relative; z-index: 80; }
    .routesGrid .routeCell:hover{ z-index: 90; }
    .routesGrid .routeName:hover{ z-index: 100; }

    @media (max-width: 600px) {
      .search-section { flex-direction: column; align-items: flex-start; }
      .search-input-wrapper { width: 100%; }
      button { width: 100%; }

      .status-strip th,
      .status-strip td{
        padding: 7px 4px;
        font-size: 12px;
      }
      .status-strip .statusCell{ font-size: 12px; }

      .top-link{ right: 12px; }
    }
  </style>
</head>

<body>
  <!-- MAIN SEARCH LOADING OVERLAY -->
  <div id="loadingOverlay" class="loading-overlay" aria-live="polite" aria-busy="true">
    <div class="loading-panel">
      <div class="spinner" aria-hidden="true"></div>
      <p class="loading-title" id="loadingTitle">Loading…</p>
      <p class="loading-sub" id="loadingSub">Fetching routes.</p>
    </div>
  </div>

  <!-- ROUTES STATUS OVERLAY -->
  <div id="routesOverlay" class="overlay" aria-modal="true" role="dialog">
    <div class="overlayPanel">
      <div class="overlayHeader">
        <div class="overlayTitle">Routes Status</div>
        <div class="overlayControls">
          <button class="overlayBtn" id="routesRefreshBtn">Refresh</button>
          <button class="overlayClose" id="routesCloseBtn">Close</button>
        </div>
      </div>

      <div class="overlayBody">
        <div id="routesOverlayLoading" style="display:none;">
          <div class="overlayLoadingRow">
            <div class="overlaySpinner" aria-hidden="true"></div>
            <div class="overlayLoadingText">Loading routes and live status…</div>
          </div>
        </div>

        <div class="routesGridWrap" id="routesGridWrap" style="display:none;">
          <table class="routesGrid" id="routesGrid"></table>
        </div>

        <div id="routesOverlayMsg" style="display:none;margin:10px auto;max-width:720px;font-size:13px;color:#a00;background:#ffe5e5;padding:10px 12px;border-radius:8px;border:1px solid #f3bcbc;">
          Error loading routes status.
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="top-link" id="routesStatusLink">Routes Status</div>

    <h1>Transport Route Checker</h1>

    <div class="search-section">
      <label for="postcodeInput">Postcode prefix:</label>
      <div class="search-input-wrapper">
        <input id="postcodeInput" type="text" placeholder="e.g. M34" autocomplete="off">
        <button id="searchButton">Search</button>
      </div>
    </div>

    <div id="noResults" class="no-results" style="display:none;">
      No routing information found for that postcode prefix.
    </div>

    <!-- LANDING: Carrier table shows before any successful search -->
    <div id="carrierBlock" class="channel-block" style="display:block;">
      <div class="channel-header">
        <div class="channel-title">Carrier</div>
        <div style="font-size:12px; color:#666;">Cut-off: 2pm (Mon–Fri, excluding UK bank holidays)</div>
      </div>

      <table>
        <colgroup>
          <col style="width: 55%">
          <col style="width: 45%">
        </colgroup>
        <thead>
          <tr>
            <th>Route</th>
            <th>Next Delivery</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>3PLCO Overnight</td>
            <td class="lead-time" id="carrierOvernightNext">—</td>
          </tr>
          <tr>
            <td>3PLCO 1-3 Day</td>
            <td class="lead-time" id="carrier13Next">—</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div id="resultsMeta" class="results-header" style="display:none;"></div>
    <div id="resultsContainer"></div>
  </div>

  <div id="channelTooltip"></div>

  <script>
    // ============================================================
    // CONFIG
    // ============================================================
    const CONFIG = {
      API_URL: "https://script.google.com/macros/s/AKfycbz4A-9fYDa5hbzvP_LxCka1Mwxfg8MYQj4lwKx1oPFRWBC2PX71z64neOFmpBgjDD8oAw/exec",
      DAYS_AHEAD: 10,

      // ROUTES now come from Google Sheets published CSV:
      ROUTES_SHEET_CSV_URL: "https://docs.google.com/spreadsheets/d/e/2PACX-1vRH6-jQDjHdpThiVhGe1mwrfOD_QRYbYYlCx8Mo1HvA-vLxudRTnpJMRWEZlyxGE-f9OXtnQBGDWoLB/pub?gid=0&single=true&output=csv",

      BANK_HOLIDAYS_CSV_URL: "bank_holidays.csv",
      CHANNEL_RULES_CSV_URL: "channel_rules.csv",

      // Used for overlay schedule inference (matches admin logic)
      COMPONENT_CHANNEL_NAME: "Component Channel"
    };

    const STATUS = {
      AVAILABLE: "Available",
      FULL_WEIGHT: "Full - On Weight",
      FULL_DROPS: "Full - On Drops",
      CLOSED: "Closed"
    };

    // ============================================================
    // MAIN SEARCH LOADING UI HELPERS
    // ============================================================
    function setLoading(isLoading, title, sub){
      const overlay = document.getElementById("loadingOverlay");
      const t = document.getElementById("loadingTitle");
      const s = document.getElementById("loadingSub");
      const btn = document.getElementById("searchButton");
      const input = document.getElementById("postcodeInput");

      if (title) t.textContent = title;
      if (sub) s.textContent = sub;

      overlay.style.display = isLoading ? "flex" : "none";
      btn.disabled = isLoading;
      input.disabled = isLoading;
    }

    function clearResultsForLoading(){
      document.getElementById("carrierBlock").style.display = "none";
      document.getElementById("resultsMeta").style.display = "none";
      document.getElementById("resultsContainer").innerHTML = "";
      document.getElementById("noResults").style.display = "none";
    }

    // ============================================================
    // DELIMITER-DETECTING PARSER (comma CSV or tab TSV)
    // ============================================================
    function stripBom(s) {
      return s && s.charCodeAt(0) === 0xFEFF ? s.slice(1) : s;
    }

    function detectDelimiter(headerLine) {
      if (headerLine.includes("\t")) return "\t";
      return ",";
    }

    function splitLine(line, delim) {
      return line.split(delim).map(x => x.trim());
    }

    function parseDelimited(text) {
      const cleanedText = stripBom(String(text || ""));
      const lines = cleanedText.split(/\r?\n/).filter(l => l.trim() !== "");
      if (!lines.length) return { headers: [], rows: [] };

      const delim = detectDelimiter(lines[0]);
      const headers = splitLine(lines[0], delim);

      const rows = [];
      for (const line of lines.slice(1)) {
        const cols = splitLine(line, delim);
        const obj = {};
        headers.forEach((h, i) => obj[h] = (cols[i] || ""));
        rows.push(obj);
      }
      return { headers, rows };
    }

    // ============================================================
    // CHANNEL RULES (LOADED FROM channel_rules.csv)
    // ============================================================
    let channelRules = {};

    function loadChannelRules() {
      fetch(CONFIG.CHANNEL_RULES_CSV_URL + "?cb=" + Date.now())
        .then(r => {
          if (!r.ok) throw new Error("Failed to load channel_rules.csv");
          return r.text();
        })
        .then(text => {
          const parsed = parseDelimited(text);
          const out = {};
          parsed.rows.forEach(row => {
            const channel = (row.channel || "").trim();
            const rulesCell = (row.rules || "").trim();
            if (!channel) return;

            const parts = rulesCell.split("|").map(p => p.trim()).filter(Boolean);
            let html = `<strong>${channel} rules</strong>`;
            if (parts.length) html += "<br>" + parts.map(p => "- " + p).join("<br>");
            out[channel] = html;
          });
          channelRules = out;
        })
        .catch(err => {
          console.error("Error loading channel_rules.csv:", err);
          channelRules = {};
        });
    }

    // ============================================================
    // BANK HOLIDAYS (LOADED FROM bank_holidays.csv)
    // ============================================================
    let bankHolidaySet = new Set(); // ISO YYYY-MM-DD
    let bankHolidaysReady = Promise.resolve();

    function toISODateKey(dateObj) {
      const y = dateObj.getFullYear();
      const m = String(dateObj.getMonth() + 1).padStart(2, "0");
      const d = String(dateObj.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }

    function loadBankHolidays() {
      return fetch(CONFIG.BANK_HOLIDAYS_CSV_URL + "?cb=" + Date.now())
        .then(r => {
          if (!r.ok) throw new Error("Failed to load bank_holidays.csv");
          return r.text();
        })
        .then(text => {
          const parsed = parseDelimited(text);
          const set = new Set();

          parsed.rows.forEach(row => {
            const d = (row.date || "").trim();           // expected YYYY-MM-DD
            const div = (row.division || "").trim();     // england-and-wales
            if (!d) return;
            if (!div || div === "england-and-wales") set.add(d);
          });

          bankHolidaySet = set;
        })
        .catch(err => {
          console.warn("Bank holidays not loaded (continuing without them):", err);
          bankHolidaySet = new Set();
        });
    }

    // ============================================================
    // ROUTES PARSING (routes from Google Sheets CSV)
    // ============================================================
    function normalisePrefix(v) {
      return String(v || "").toUpperCase().replace(/\s+/g, "").trim();
    }

    function parseRoutes(text) {
      const parsed = parseDelimited(text);
      return parsed.rows.map(row => {
        const daysArray = String(row.days || "")
          .split("|")
          .map(d => d.trim())
          .filter(Boolean);

        return {
          prefix: normalisePrefix(row.prefix),
          route: String(row.route || "").trim(),
          channel: String(row.channel || "").trim(),
          serviceType: String(row.serviceType || "").trim(),
          leadTime: String(row.leadTime || "").trim(),
          days: daysArray
        };
      }).filter(r => r.prefix && r.channel);
    }

    async function fetchRoutesFromSheet() {
      const url = CONFIG.ROUTES_SHEET_CSV_URL + "&cb=" + Date.now();
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to load routes sheet CSV");
      return await res.text();
    }

    // ============================================================
    // WORKING DAY + CUTOFF HELPERS (channels + Carrier + overlay)
    // ============================================================
    function parseLeadTimeWorkingDays(leadTimeText) {
      const t = String(leadTimeText || "").toLowerCase();
      const m = t.match(/(\d+)/);
      if (m) return parseInt(m[1], 10);
      if (t.includes("next day")) return 1;
      if (t.includes("same day")) return 0;
      return 0;
    }

    function isWorkingDay(dateObj) {
      const day = dateObj.getDay(); // 0 Sun ... 6 Sat
      if (day === 0 || day === 6) return false;
      const iso = toISODateKey(dateObj);
      if (bankHolidaySet.has(iso)) return false;
      return true;
    }

    function startOfDay(dateObj) {
      return new Date(dateObj.getFullYear(), dateObj.getMonth(), dateObj.getDate());
    }

    function nextWorkingDay(dateObj) {
      let d = startOfDay(dateObj);
      do { d.setDate(d.getDate() + 1); } while (!isWorkingDay(d));
      return d;
    }

    function addWorkingDays(dateObj, n) {
      let d = startOfDay(dateObj);
      let remaining = n;
      while (remaining > 0) {
        d.setDate(d.getDate() + 1);
        if (isWorkingDay(d)) remaining--;
      }
      return d;
    }

    function weekdayName(dateObj) {
      return dateObj.toLocaleDateString("en-GB", { weekday: "long" });
    }

    function weekdayShort(dateObj){
      return dateObj.toLocaleDateString("en-GB", { weekday: "short" });
    }

    function displayDateShort(dateObj){
      const dd = String(dateObj.getDate()).padStart(2, "0");
      const mm = String(dateObj.getMonth() + 1).padStart(2, "0");
      const yy = String(dateObj.getFullYear()).slice(-2);
      return `${dd}/${mm}/${yy}`;
    }

    function formatDayDate(dateObj) {
      const day = weekdayName(dateObj);
      const dateStr = dateObj.toLocaleDateString("en-GB", { day: "2-digit", month: "2-digit", year: "2-digit" });
      return `${day} ${dateStr}`;
    }

    // Existing route checker booking/cutoff start (used for next-delivery + strips)
    function getStartDateConsideringCutoff() {
      const now = new Date();
      const cutoffHour = 14; // 2pm

      let start = startOfDay(now);

      if (!isWorkingDay(start)) {
        return nextWorkingDay(start);
      }

      const afterCutoff =
        (now.getHours() > cutoffHour) ||
        (now.getHours() === cutoffHour && now.getMinutes() > 0);

      if (afterCutoff) start = nextWorkingDay(start);
      return start;
    }

    // NEW (requested): overlay grid date window starts from NEXT DAY onwards
    // - If before 2pm: first column = next working day
    // - If after 2pm: first column = following working day (i.e. skip next working day)
    function getOverlayGridStartDate() {
      const now = new Date();
      const cutoffHour = 14;

      let today = startOfDay(now);

      // if today is not a working day, treat "today" as next working day for rule purposes,
      // then apply "next day onwards" from there.
      if (!isWorkingDay(today)) {
        today = nextWorkingDay(today);
      }

      const afterCutoff =
        (now.getHours() > cutoffHour) ||
        (now.getHours() === cutoffHour && now.getMinutes() > 0);

      const first = nextWorkingDay(today);          // next working day
      return afterCutoff ? nextWorkingDay(first)    // following working day
                         : first;                   // next working day
    }

    // Build N WORKING DAYS (exclude weekends + bank holidays), starting from given date (must be working day).
    function buildWorkingDateColsFrom(startDate, n){
      const cols = [];
      let d = startOfDay(startDate);

      if (!isWorkingDay(d)) d = nextWorkingDay(d);

      let safety = 0;
      while (cols.length < n && safety < 730){
        if (isWorkingDay(d)){
          cols.push({
            date: new Date(d),
            iso: toISODateKey(d),
            weekday: d.getDay(),
            head: `${weekdayShort(d)}<br>${displayDateShort(d)}`
          });
        }
        d.setDate(d.getDate() + 1);
        safety++;
      }
      return cols;
    }

    // Carrier next dates
    function computeCarrierNextDates() {
      const start = getStartDateConsideringCutoff();
      const overnight = addWorkingDays(start, 1);
      const day3 = addWorkingDays(start, 3);

      document.getElementById("carrierOvernightNext").textContent = formatDayDate(overnight);
      document.getElementById("carrier13Next").textContent = formatDayDate(day3);
    }

    // ============================================================
    // CHANNEL NEXT DELIVERY CALCULATION
    // ============================================================
    function findNextDeliveryDate(allowedDays, leadTimeText) {
      if (!Array.isArray(allowedDays) || allowedDays.length === 0) return null;

      const allowed = new Set(allowedDays.map(d => String(d).trim().toLowerCase()));
      const start = getStartDateConsideringCutoff();
      const leadDays = parseLeadTimeWorkingDays(leadTimeText);
      const earliest = (leadDays > 0) ? addWorkingDays(start, leadDays) : start;

      let d = startOfDay(earliest);
      for (let i = 0; i < 120; i++) {
        const dayLower = weekdayName(d).toLowerCase();
        if (allowed.has(dayLower) && d >= earliest && isWorkingDay(d)) return d;
        d.setDate(d.getDate() + 1);
      }
      return null;
    }

    // ============================================================
    // ROUTE STATUS OVERRIDES (Google Sheet via Apps Script)
    // ============================================================
    const overridesMap = new Map();
    function ovKey(dateISO, route){ return `${dateISO}||${route}`; }

    async function loadOverridesForRange(fromISO, toISO){
      overridesMap.clear();
      const url = `${CONFIG.API_URL}?action=get&from=${encodeURIComponent(fromISO)}&to=${encodeURIComponent(toISO)}`;
      const res = await fetch(url, { cache: "no-store" });
      const data = await res.json().catch(()=>null);
      if (!data || !data.ok) throw new Error(`API failed: ${(data && data.error) ? data.error : "Unknown error"}`);

      for (const row of (data.rows || [])){
        const date = String(row.date || "").trim();
        const route = String(row.route || "").trim();
        const status = String(row.status || "").trim();
        if (!date || !route || !status) continue;
        overridesMap.set(ovKey(date, route), status);
      }
    }

    // ============================================================
    // STATUS STRIP LOGIC (View-only, channel rule wins)
    // ============================================================
    function earliestBookableDeliveryDate(leadDays){
      const start = getStartDateConsideringCutoff();
      return (leadDays > 0) ? addWorkingDays(start, leadDays) : start;
    }

    function routeRunsOnDayName(runDays, dateObj){
      const d = weekdayName(dateObj).toLowerCase();
      return runDays.has(d);
    }

    function classifyStatusCell({ runs, isClosed, overrideStatus }){
      if (!runs){
        return { cls: "inactiveCell statusCell", text: "" };
      }

      if (isClosed){
        return { cls: "fullWeightCell statusCell", text: STATUS.CLOSED };
      }

      if (overrideStatus === STATUS.FULL_WEIGHT){
        return { cls: "fullWeightCell statusCell", text: STATUS.FULL_WEIGHT };
      }
      if (overrideStatus === STATUS.FULL_DROPS){
        return { cls: "fullDropsCell statusCell", text: STATUS.FULL_DROPS };
      }
      if (overrideStatus === STATUS.AVAILABLE){
        return { cls: "availableCell statusCell", text: STATUS.AVAILABLE };
      }

      return { cls: "availableCell statusCell", text: STATUS.AVAILABLE };
    }

    function buildStatusStripHTML(route, runDaysArray, leadTimeText, dateCols){
      const leadDays = parseLeadTimeWorkingDays(leadTimeText);
      const earliest = earliestBookableDeliveryDate(leadDays);

      const runDays = new Set((runDaysArray || []).map(d => String(d).trim().toLowerCase()).filter(Boolean));

      let thead = "<thead><tr>";
      for (const c of dateCols){
        thead += `<th>${c.head}</th>`;
      }
      thead += "</tr></thead>";

      let tbody = "<tbody><tr>";
      for (const c of dateCols){
        const runs = routeRunsOnDayName(runDays, c.date);
        const isClosed = runs && (startOfDay(c.date) < startOfDay(earliest));
        const ov = overridesMap.get(ovKey(c.iso, route));
        const { cls, text } = classifyStatusCell({ runs, isClosed, overrideStatus: ov });
        tbody += `<td class="${cls}">${text}</td>`;
      }
      tbody += "</tr></tbody>";

      return `
        <div class="status-strip" aria-label="Route status (next ${dateCols.length} working days)">
          <table>
            ${thead}
            ${tbody}
          </table>
        </div>
      `;
    }

    // ============================================================
    // CORE HELPERS
    // ============================================================
    function normaliseInputPostcode(raw) {
      return raw ? raw.toUpperCase().replace(/\s+/g, "") : "";
    }

    function findBestMatchingPrefix(routingData, cleaned) {
      const prefixes = [...new Set(routingData.map(r => r.prefix))];
      const matches = prefixes.filter(p => cleaned.startsWith(p));
      return matches.sort((a, b) => b.length - a.length)[0] || null;
    }

    function groupByChannel(rows) {
      return rows.reduce((acc, r) => {
        acc[r.channel] = acc[r.channel] || [];
        acc[r.channel].push(r);
        return acc;
      }, {});
    }

    function sortDays(days) {
      const order = ["MONDAY","TUESDAY","WEDNESDAY","THURSDAY","FRIDAY","SATURDAY","SUNDAY"];
      return days.slice().sort((a, b) => {
        const aIndex = order.indexOf(String(a).toUpperCase());
        const bIndex = order.indexOf(String(b).toUpperCase());
        return aIndex - bIndex;
      });
    }

    // ============================================================
    // Build results FAST: first table immediately, then fill strips later
    // ============================================================
    function buildResultsHTMLFast(rows, usedPrefix, originalInput) {
      const grouped = groupByChannel(rows);
      const channels = Object.keys(grouped).sort();

      const resultsContainer = document.getElementById("resultsContainer");
      const resultsMeta = document.getElementById("resultsMeta");
      const noResults = document.getElementById("noResults");

      if (!channels.length) {
        resultsMeta.style.display = "none";
        resultsContainer.innerHTML = "";
        noResults.style.display = "block";
        return;
      }

      noResults.style.display = "none";
      resultsMeta.style.display = "block";
      resultsMeta.textContent =
        `Results for postcode: ${originalInput || usedPrefix} (matched prefix: ${usedPrefix})`;

      let html = "";

      channels.forEach((channel, idx) => {
        const rowsForChannel = grouped[channel];

        const route = rowsForChannel[0].route;
        const serviceType = rowsForChannel[0].serviceType;
        const leadTime = rowsForChannel[0].leadTime;

        const allDays = sortDays([...new Set(rowsForChannel.flatMap(r => r.days))]);

        const nextDate = findNextDeliveryDate(allDays, leadTime);
        const nextDeliveryText = nextDate ? formatDayDate(nextDate) : "";

        // placeholder container to populate later
        const stripId = `strip_${idx}_${route.replace(/\s+/g,'_')}`;

        html += `
          <div class="channel-block">
            <div class="channel-header">
              <div class="channel-title">${channel}</div>
              <div class="channel-rules-trigger" data-channel="${channel}">
                Hover here for channel rules
              </div>
            </div>

            <table>
              <colgroup>
                <col style="width: 24%">
                <col style="width: 35%">
                <col style="width: 12%">
                <col style="width: 12%">
                <col style="width: 17%">
              </colgroup>
              <thead>
                <tr>
                  <th>Route</th>
                  <th>Delivery Days</th>
                  <th>Delivery Type</th>
                  <th>Lead Time</th>
                  <th>Next Delivery</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>${route}</td>
                  <td>${allDays.join(", ")}</td>
                  <td>${serviceType}</td>
                  <td class="lead-time">${leadTime}</td>
                  <td class="lead-time">${nextDeliveryText}</td>
                </tr>
              </tbody>
            </table>

            <div class="strip-loading" id="${stripId}">Loading route status…</div>
          </div>
        `;
      });

      resultsContainer.innerHTML = html;
      attachChannelRuleEvents();
    }

    function attachChannelRuleEvents() {
      const triggers = document.querySelectorAll(".channel-rules-trigger");
      const tooltip = document.getElementById("channelTooltip");

      function positionTooltip(e) {
        const offset = 12;
        let x = e.clientX + offset;
        let y = e.clientY + offset;

        tooltip.style.left = x + "px";
        tooltip.style.top = y + "px";

        const rect = tooltip.getBoundingClientRect();
        if (rect.right > window.innerWidth - 10) {
          x = e.clientX - rect.width - offset;
          tooltip.style.left = x + "px";
        }
        if (rect.bottom > window.innerHeight - 10) {
          y = e.clientY - rect.height - offset;
          tooltip.style.top = y + "px";
        }
      }

      triggers.forEach(trigger => {
        trigger.addEventListener("mouseenter", e => {
          const channel = trigger.getAttribute("data-channel");
          const content = channelRules[channel] || "No rules defined for this channel.";
          tooltip.innerHTML = content;
          tooltip.style.display = "block";
          positionTooltip(e);
        });

        trigger.addEventListener("mousemove", positionTooltip);
        trigger.addEventListener("mouseleave", () => { tooltip.style.display = "none"; });
      });
    }

    // After overrides are available: replace placeholders with actual strips
    function populateStrips(rows){
      const grouped = groupByChannel(rows);
      const channels = Object.keys(grouped).sort();

      channels.forEach((channel, idx) => {
        const rowsForChannel = grouped[channel];

        const route = rowsForChannel[0].route;
        const leadTime = rowsForChannel[0].leadTime;

        const allDays = sortDays([...new Set(rowsForChannel.flatMap(r => r.days))]);

        const nextDate = findNextDeliveryDate(allDays, leadTime);
        const stripStart = nextDate || getStartDateConsideringCutoff();
        const dateColsForChannel = buildWorkingDateColsFrom(stripStart, CONFIG.DAYS_AHEAD);

        const stripHTML = buildStatusStripHTML(route, allDays, leadTime, dateColsForChannel);

        const stripId = `strip_${idx}_${route.replace(/\s+/g,'_')}`;
        const el = document.getElementById(stripId);
        if (el){
          el.outerHTML = stripHTML; // replace placeholder div with strip
        }
      });
    }

    // ============================================================
    // LANDING / VISIBILITY CONTROL
    // ============================================================
    function showLandingCarrier() {
      document.getElementById("carrierBlock").style.display = "block";
      document.getElementById("resultsMeta").style.display = "none";
      document.getElementById("resultsContainer").innerHTML = "";
      document.getElementById("noResults").style.display = "none";
    }

    function hideLandingCarrier() {
      document.getElementById("carrierBlock").style.display = "none";
    }

    // ============================================================
    // SEARCH HANDLING
    // ============================================================
    async function performSearch() {
      const input = document.getElementById("postcodeInput").value.trim();

      if (!input) {
        showLandingCarrier();
        document.getElementById("noResults").style.display = "block";
        document.getElementById("noResults").textContent = "Please enter a postcode prefix.";
        return;
      }

      clearResultsForLoading();
      setLoading(true, "Loading route information…", "Fetching routes.");

      try{
        await bankHolidaysReady;

        const cleaned = normaliseInputPostcode(input);
        const text = await fetchRoutesFromSheet();

        const routingData = parseRoutes(text);
        const bestPrefix = findBestMatchingPrefix(routingData, cleaned);

        if (!bestPrefix) {
          setLoading(false);
          showLandingCarrier();
          document.getElementById("noResults").style.display = "block";
          document.getElementById("noResults").textContent = "No routing information found for that postcode prefix.";
          return;
        }

        hideLandingCarrier();

        const matchingRows = routingData.filter(r => r.prefix === bestPrefix);

        // Build FIRST TABLES immediately
        buildResultsHTMLFast(matchingRows, bestPrefix, input);

        // Hide spinner ASAP so user can see route checker info
        setLoading(false);

        // In the background: load overrides and then populate strips
        (async () => {
          try{
            const grouped = groupByChannel(matchingRows);
            const channels = Object.keys(grouped);

            let globalFromISO = null;
            let globalToISO = null;

            for (const channel of channels){
              const rowsForChannel = grouped[channel];

              const leadTime = rowsForChannel[0].leadTime;
              const allDays = sortDays([...new Set(rowsForChannel.flatMap(r => r.days))]);

              const nextDate = findNextDeliveryDate(allDays, leadTime);
              const stripStart = nextDate || getStartDateConsideringCutoff();
              const cols = buildWorkingDateColsFrom(stripStart, CONFIG.DAYS_AHEAD);

              if (cols.length){
                const fromISO = cols[0].iso;
                const toISO = cols[cols.length - 1].iso;

                if (!globalFromISO || fromISO < globalFromISO) globalFromISO = fromISO;
                if (!globalToISO || toISO > globalToISO) globalToISO = toISO;
              }
            }

            if (globalFromISO && globalToISO){
              await loadOverridesForRange(globalFromISO, globalToISO);
            }

            populateStrips(matchingRows);

          }catch(apiErr){
            console.warn("Route status API not available. Leaving strips as loading/default:", apiErr);
            // If API fails, still show default "Available" cells by populating with empty overridesMap.
            populateStrips(matchingRows);
          }
        })();

      }catch(err){
        console.error("Error during search:", err);
        setLoading(false);
        showLandingCarrier();
        alert("Routing data is not available at the moment. Please try again in a moment or contact the system owner.");
      }
    }

    document.getElementById("searchButton").onclick = performSearch;
    document.getElementById("postcodeInput").addEventListener("keydown", e => {
      if (e.key === "Enter") { e.preventDefault(); performSearch(); }
    });

    // ============================================================
    // OVERLAY (View-only full grid)
    // ============================================================
    const overlayEl = document.getElementById("routesOverlay");
    const overlayMsgEl = document.getElementById("routesOverlayMsg");
    const overlayLoadingEl = document.getElementById("routesOverlayLoading");
    const gridWrapEl = document.getElementById("routesGridWrap");
    const gridEl = document.getElementById("routesGrid");
    const refreshBtn = document.getElementById("routesRefreshBtn");
    const closeBtn = document.getElementById("routesCloseBtn");
    const openLink = document.getElementById("routesStatusLink");

    let overlayLoadedOnce = false;

    function openOverlay(){
      overlayEl.style.display = "flex";
      document.body.style.overflow = "hidden";
      // lazy load on open (unless already loaded)
      if (!overlayLoadedOnce) loadRoutesOverlay(true);
    }

    function closeOverlay(){
      overlayEl.style.display = "none";
      document.body.style.overflow = "";
    }

    overlayEl.addEventListener("click", (e) => {
      if (e.target === overlayEl) closeOverlay();
    });
    closeBtn.addEventListener("click", closeOverlay);
    openLink.addEventListener("click", openOverlay);
    window.addEventListener("keydown", (e) => {
      if (overlayEl.style.display === "flex" && e.key === "Escape") closeOverlay();
    });

    refreshBtn.addEventListener("click", () => loadRoutesOverlay(true));

    function showOverlayLoading(isLoading){
      overlayLoadingEl.style.display = isLoading ? "block" : "none";
      refreshBtn.disabled = isLoading;
      overlayMsgEl.style.display = "none";
      if (isLoading){
        gridWrapEl.style.display = "none";
      }
    }

    function showOverlayError(msg){
      overlayMsgEl.textContent = msg || "Error loading routes status.";
      overlayMsgEl.style.display = "block";
      gridWrapEl.style.display = "none";
    }

    // --- Tooltip positioning: open right by default, flip left if needed (requested)
    function setTooltipSide(tooltipEl, preferRight){
      tooltipEl.style.left = "auto";
      tooltipEl.style.right = "auto";

      if (preferRight){
        tooltipEl.style.left = "0";
      } else {
        tooltipEl.style.right = "0";
      }
    }

    function adjustAllRouteTooltips(){
      // After grid render: set tooltip side based on available viewport room.
      const routeNameEls = gridEl.querySelectorAll(".routeName");
      routeNameEls.forEach(nameEl => {
        const tooltip = nameEl.querySelector(".routeTooltip");
        if (!tooltip) return;

        // default to open RIGHT (aligned with left edge of route cell)
        setTooltipSide(tooltip, true);

        // measure on hover: we also do a pre-check based on current layout
        const rect = nameEl.getBoundingClientRect();
        const approxWidth = 380; // average tooltip width (min 280, max 520)
        const roomRight = window.innerWidth - rect.left;
        const roomLeft = rect.right;

        // If not enough room to the right but enough to the left, flip.
        const shouldFlipLeft = (roomRight < approxWidth) && (roomLeft > approxWidth);
        setTooltipSide(tooltip, !shouldFlipLeft);

        // Also clamp so it doesn't spill off-screen on tiny widths
        tooltip.style.maxWidth = Math.min(520, Math.max(280, window.innerWidth - 60)) + "px";
      });
    }

    window.addEventListener("resize", () => {
      if (overlayEl.style.display === "flex") adjustAllRouteTooltips();
    });

    // --- Admin-style postcode group building (view-only)
    function pad2(n){ return String(n).padStart(2,"0"); }
    function toISODate(d){ return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`; }
    function escapeHTML(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function normaliseDistrictToken(token){
      const t = String(token || "").trim().toUpperCase();
      const m = t.match(/^([A-Z]{1,2})\s*0*(\d{1,2})([A-Z]?)$/);
      if (!m) return null;
      const area = m[1];
      const num = parseInt(m[2], 10);
      const suffix = m[3] || "";
      if (!Number.isFinite(num)) return null;
      return { area, num, suffix, raw: `${area}${num}${suffix}` };
    }

    function extractDistrictsFromPrefixCell(cell){
      const text = String(cell || "").toUpperCase();
      const matches = text.match(/[A-Z]{1,2}\s*0*\d{1,2}[A-Z]?/g) || [];
      const out = [];
      for (const m of matches){
        const d = normaliseDistrictToken(m.replace(/\s+/g,""));
        if (d) out.push(d);
      }
      return out;
    }

    function groupDistrictsToRanges(districts){
      const byAreaNums = new Map();
      const suffixTokens = new Map();

      for (const d of districts){
        if (!d) continue;
        if (d.suffix){
          if (!suffixTokens.has(d.area)) suffixTokens.set(d.area, new Set());
          suffixTokens.get(d.area).add(d.raw);
          continue;
        }
        if (!byAreaNums.has(d.area)) byAreaNums.set(d.area, new Set());
        byAreaNums.get(d.area).add(d.num);
      }

      const parts = [];
      const areas = Array.from(new Set([...byAreaNums.keys(), ...suffixTokens.keys()]))
        .sort((a,b)=>a.localeCompare(b,"en-GB"));

      for (const area of areas){
        const numsSet = byAreaNums.get(area) || new Set();
        const nums = Array.from(numsSet).sort((a,b)=>a-b);

        if (nums.length){
          let start = nums[0], prev = nums[0];
          for (let i=1;i<nums.length;i++){
            const n = nums[i];
            if (n === prev + 1){ prev = n; continue; }
            parts.push(start === prev ? `${area}${start}` : `${area}${start}–${area}${prev}`);
            start = prev = n;
          }
          parts.push(start === prev ? `${area}${start}` : `${area}${start}–${area}${prev}`);
        }

        const sufSet = suffixTokens.get(area);
        if (sufSet && sufSet.size){
          const suf = Array.from(sufSet).sort((a,b)=>a.localeCompare(b,"en-GB",{numeric:true}));
          for (const t of suf) parts.push(t);
        }
      }

      const cleaned = parts.map(p => p.replace(/^([A-Z]{1,2}\d+)–\1([A-Z]{1,2})(\d+)$/, "$1–$2$3"));
      return cleaned.join("; ");
    }

    function truthy(v){
      const s = String(v||"").trim().toLowerCase();
      return !!(s && s !== "0" && s !== "no" && s !== "false" && s !== "n");
    }

    function weekdayIndexFromName(name){
      const n = String(name||"").trim().toLowerCase();
      const map = {
        "sun":0,"sunday":0,
        "mon":1,"monday":1,
        "tue":2,"tues":2,"tuesday":2,
        "wed":3,"wednesday":3,
        "thu":4,"thur":4,"thurs":4,"thursday":4,
        "fri":5,"friday":5,
        "sat":6,"saturday":6
      };
      return (n in map) ? map[n] : null;
    }

    // Build view-only overlay grid (schedule inferred from COMPONENT_CHANNEL_NAME like admin)
    async function loadRoutesOverlay(force){
      try{
        showOverlayLoading(true);
        overlayLoadedOnce = true;

        await bankHolidaysReady;

        // 1) Load routes from Google sheet
        const text = await fetchRoutesFromSheet();
        const parsed = parseDelimited(text);
        const rows = parsed.rows || [];

        // 2) Filter to component channel to infer schedules / postcode groups
        const targetChannel = String(CONFIG.COMPONENT_CHANNEL_NAME || "").trim().toLowerCase();
        const schedule = new Map(); // route -> Set(weekdayIndex)
        const routeDistricts = new Map(); // route -> districts array

        // Try to support either boolean weekday columns OR "days" column used in checker
        // (your sheet for checker uses "days" pipe list, so we parse that too)
        function parseRunDaysFromRow(r){
          // If "days" exists: it's day names separated by | (Mon..)
          const daysStr = String(r.days || "").trim();
          if (daysStr){
            const set = new Set();
            daysStr.split("|").map(x=>x.trim()).filter(Boolean).forEach(dayName => {
              const idx = weekdayIndexFromName(dayName);
              if (idx !== null) set.add(idx);
            });
            return set;
          }
          // Otherwise, look for columns named Mon/Tue/... with truthy values
          const set = new Set();
          for (const k of Object.keys(r)){
            const idx = weekdayIndexFromName(k);
            if (idx !== null && truthy(r[k])) set.add(idx);
          }
          return set;
        }

        for (const r of rows){
          const channel = String(r.channel || "").trim().toLowerCase();
          if (targetChannel && channel !== targetChannel) continue;

          const route = String(r.route || "").trim();
          if (!route) continue;

          // ignore 3PLCO and short codes like admin
          if (route.toUpperCase().startsWith("3PLCO")) continue;
          if (route.length <= 5) continue;

          const days = parseRunDaysFromRow(r);
          if (days.size){
            if (!schedule.has(route)) schedule.set(route, days);
          }

          const prefixCell = r.prefix || "";
          if (!routeDistricts.has(route)) routeDistricts.set(route, []);
          routeDistricts.get(route).push(...extractDistrictsFromPrefixCell(prefixCell));
        }

        if (schedule.size === 0){
          showOverlayLoading(false);
          showOverlayError(`No route schedules could be inferred for "${CONFIG.COMPONENT_CHANNEL_NAME}".`);
          return;
        }

        // 3) Build tooltip postcode groups
        const routePostcodeGroups = new Map();
        for (const [route, districts] of routeDistricts.entries()){
          routePostcodeGroups.set(route, groupDistrictsToRanges(districts));
        }

        // 4) Build date columns from "next day onwards" cut-off rule (requested)
        const start = getOverlayGridStartDate();
        const dateCols = buildWorkingDateColsFrom(start, CONFIG.DAYS_AHEAD);
        if (!dateCols.length){
          showOverlayLoading(false);
          showOverlayError("No working-day columns could be generated.");
          return;
        }

        // 5) Load overrides for that date window
        try{
          await loadOverridesForRange(dateCols[0].iso, dateCols[dateCols.length - 1].iso);
        }catch(err){
          console.warn("Overlay: status API failed; showing defaults", err);
          overridesMap.clear();
        }

        // 6) Render grid (view-only)
        const routes = Array.from(schedule.keys())
          .sort((a,b)=>a.localeCompare(b,"en-GB",{numeric:true,sensitivity:"base"}));

        let html = "<thead><tr>";
        html += `<th class="routeHead">Route</th>`;
        for (const c of dateCols){
          html += `<th>${c.head}</th>`;
        }
        html += "</tr></thead><tbody>";

        for (const route of routes){
          html += `<tr>`;
          const groups = routePostcodeGroups.get(route) || "";
          html += `
            <td class="routeCell">
              <span class="routeName">
                ${escapeHTML(route)}
                <span class="routeTooltip">
                  <div class="routeTooltipTitle">Postcode groups</div>
                  <div class="routeTooltipBody">${escapeHTML(groups || "No postcode groups found for this route.")}</div>
                </span>
              </span>
            </td>
          `;

          const runDays = schedule.get(route) || new Set();

          for (const c of dateCols){
            const runs = runDays.has(c.weekday);
            if (!runs){
              html += `<td class="gridInactive"></td>`;
              continue;
            }
            const ov = overridesMap.get(ovKey(c.iso, route));
            let cls = "gridAvailable";
            let txt = STATUS.AVAILABLE;

            if (ov === STATUS.FULL_WEIGHT){ cls = "gridFullWeight"; txt = STATUS.FULL_WEIGHT; }
            else if (ov === STATUS.FULL_DROPS){ cls = "gridFullDrops"; txt = STATUS.FULL_DROPS; }
            else if (ov === STATUS.AVAILABLE){ cls = "gridAvailable"; txt = STATUS.AVAILABLE; }
            // no "Closed" concept on this overlay grid (admin doesn't show Closed); we keep default available

            html += `<td class="${cls}">${escapeHTML(txt)}</td>`;
          }

          html += `</tr>`;
        }

        html += "</tbody>";
        gridEl.innerHTML = html;

        // Show only the table (no "Ready" message)
        gridWrapEl.style.display = "block";
        showOverlayLoading(false);

        // Apply tooltip side logic (open to right, flip if needed)
        adjustAllRouteTooltips();

      }catch(err){
        console.error(err);
        showOverlayLoading(false);
        showOverlayError("Error loading routes status. Please try Refresh.");
      }
    }

    // ============================================================
    // INIT
    // ============================================================
    (function init() {
      loadChannelRules();

      const btn = document.getElementById("searchButton");
      btn.disabled = true;

      bankHolidaysReady = loadBankHolidays().finally(() => {
        btn.disabled = false;
        computeCarrierNextDates();
        setInterval(computeCarrierNextDates, 60 * 1000);
        window.addEventListener("focus", computeCarrierNextDates);
      });

      showLandingCarrier();
    })();
  </script>
</body>
</html>
